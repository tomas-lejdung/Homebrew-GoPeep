<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GoPeep - Viewing</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg-primary: #0a0a0a;
      --bg-secondary: #1a1a1a;
      --bg-overlay: rgba(0, 0, 0, 0.85);
      --text-primary: #ffffff;
      --text-secondary: #a0a0a0;
      --text-dim: #666666;
      --accent: #60a5fa;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --border: rgba(255, 255, 255, 0.1);
    }
    
    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      overflow: hidden;
      cursor: none;
    }
    
    body.show-ui {
      cursor: default;
    }
    
    /* Video container */
    #container {
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
    }
    
    video {
      background: #000;
      outline: none;
    }
    
    video.scale-fit {
      max-width: 100vw;
      max-height: 100vh;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    video.scale-fill {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
    }
    
    video.scale-native {
      width: auto;
      height: auto;
      max-width: none;
      max-height: none;
    }
    
    /* Top status bar */
    #status-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 12px 20px;
      background: var(--bg-overlay);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      display: flex;
      align-items: center;
      gap: 16px;
      font-size: 13px;
      z-index: 100;
      opacity: 0;
      transform: translateY(-100%);
      transition: opacity 0.3s ease, transform 0.3s ease;
      border-bottom: 1px solid var(--border);
    }
    
    #status-bar.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .status-section {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-dim);
      flex-shrink: 0;
    }
    
    .status-dot.connecting {
      background: var(--warning);
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    .status-dot.connected {
      background: var(--success);
    }
    
    .status-dot.degraded {
      background: var(--warning);
    }
    
    .status-dot.error {
      background: var(--error);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(0.9); }
    }
    
    #room-code {
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      font-weight: 600;
      color: var(--accent);
      font-size: 14px;
    }
    
    .divider {
      width: 1px;
      height: 20px;
      background: var(--border);
    }
    
    .stat-label {
      color: var(--text-dim);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .stat-value {
      color: var(--text-primary);
      font-family: "SF Mono", Monaco, monospace;
      font-size: 12px;
    }
    
    #status-right {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    /* Control bar */
    #control-bar {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      padding: 10px 16px;
      background: var(--bg-overlay);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      border: 1px solid var(--border);
    }
    
    #control-bar.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .control-btn {
      width: 40px;
      height: 40px;
      border: none;
      background: transparent;
      color: var(--text-primary);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s ease;
    }
    
    .control-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }
    
    .control-btn:active {
      background: rgba(255, 255, 255, 0.15);
    }
    
    .control-btn.active {
      color: var(--accent);
    }
    
    .control-btn svg {
      width: 20px;
      height: 20px;
    }
    
    .control-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 4px;
    }
    
    /* Scale mode selector */
    .scale-selector {
      display: flex;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      padding: 2px;
    }
    
    .scale-btn {
      padding: 6px 12px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 11px;
      font-weight: 500;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .scale-btn:hover {
      color: var(--text-primary);
    }
    
    .scale-btn.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    
    /* Waiting screen */
    #waiting {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
      z-index: 50;
    }
    
    #waiting.hidden {
      display: none;
    }
    
    .spinner {
      width: 48px;
      height: 48px;
      border: 3px solid var(--bg-secondary);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 24px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    #waiting h2 {
      font-size: 20px;
      font-weight: 500;
      margin-bottom: 8px;
    }
    
    #waiting p {
      color: var(--text-secondary);
      font-size: 14px;
    }
    
    #waiting-room {
      margin-top: 24px;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-radius: 8px;
      font-family: "SF Mono", Monaco, monospace;
      color: var(--accent);
      font-size: 16px;
      font-weight: 600;
    }
    
    /* Keyboard shortcuts help */
    #shortcuts-help {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 12px 20px;
      background: var(--bg-overlay);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      opacity: 0;
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
      border: 1px solid var(--border);
      z-index: 99;
    }
    
    #shortcuts-help.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    .shortcut {
      display: inline-flex;
      align-items: center;
      gap: 16px;
    }
    
    .shortcut + .shortcut {
      margin-left: 20px;
    }
    
    kbd {
      display: inline-block;
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      font-family: "SF Mono", Monaco, monospace;
      font-size: 11px;
      color: var(--text-primary);
      margin-right: 6px;
    }
    
    /* Stats panel */
    #stats-panel {
      position: fixed;
      top: 60px;
      right: 20px;
      padding: 16px;
      background: var(--bg-overlay);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: 8px;
      font-size: 12px;
      opacity: 0;
      transform: translateX(20px);
      transition: opacity 0.3s ease, transform 0.3s ease;
      pointer-events: none;
      border: 1px solid var(--border);
      z-index: 100;
      min-width: 180px;
    }
    
    #stats-panel.visible {
      opacity: 1;
      transform: translateX(0);
      pointer-events: auto;
    }
    
    .stats-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-dim);
      margin-bottom: 12px;
    }
    
    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
    }
    
    .stats-row + .stats-row {
      border-top: 1px solid var(--border);
      margin-top: 4px;
      padding-top: 8px;
    }
    
    .stats-label {
      color: var(--text-secondary);
    }
    
    .stats-value {
      font-family: "SF Mono", Monaco, monospace;
      color: var(--text-primary);
    }
    
    .stats-value.good { color: var(--success); }
    .stats-value.warn { color: var(--warning); }
    .stats-value.bad { color: var(--error); }
    
    /* Password dialog */
    #password-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
      z-index: 200;
    }
    
    #password-dialog.visible {
      display: flex;
    }
    
    .password-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 32px;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    
    .password-box h2 {
      font-size: 20px;
      font-weight: 500;
      margin-bottom: 8px;
    }
    
    .password-box p {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 24px;
    }
    
    .password-box .room-code {
      font-family: "SF Mono", Monaco, monospace;
      color: var(--accent);
      font-weight: 600;
    }
    
    .password-input-group {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
    }
    
    .password-input {
      flex: 1;
      padding: 12px 16px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 16px;
      font-family: "SF Mono", Monaco, monospace;
      outline: none;
    }
    
    .password-input:focus {
      border-color: var(--accent);
    }
    
    .password-input.error {
      border-color: var(--error);
    }
    
    .password-submit {
      padding: 12px 24px;
      background: var(--accent);
      border: none;
      border-radius: 8px;
      color: var(--bg-primary);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: opacity 0.2s ease;
    }
    
    .password-submit:hover {
      opacity: 0.9;
    }
    
    .password-error {
      color: var(--error);
      font-size: 13px;
      height: 20px;
    }
  </style>
</head>
<body>
  <!-- Top status bar -->
  <div id="status-bar">
    <div class="status-section">
      <div class="status-dot connecting" id="status-dot"></div>
      <span id="status-text">Connecting...</span>
    </div>
    <div class="divider"></div>
    <span id="room-code"></span>
    <div id="stream-stats" style="display: none;">
      <div class="divider"></div>
      <div class="status-section">
        <span class="stat-label">RES</span>
        <span class="stat-value" id="stat-resolution">--</span>
      </div>
      <div class="status-section">
        <span class="stat-label">FPS</span>
        <span class="stat-value" id="stat-fps">--</span>
      </div>
      <div class="status-section">
        <span class="stat-label">BITRATE</span>
        <span class="stat-value" id="stat-bitrate">--</span>
      </div>
    </div>
    <div id="status-right">
      <div class="status-section" id="viewer-count" style="display: none;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
          <circle cx="9" cy="7" r="4"></circle>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
        <span id="viewer-count-text">1</span>
      </div>
    </div>
  </div>
  
  <!-- Waiting screen -->
  <div id="waiting">
    <div class="spinner"></div>
    <h2 id="waiting-title">Connecting...</h2>
    <p id="waiting-subtitle">Establishing connection to sharer</p>
    <div id="waiting-room"></div>
  </div>
  
  <!-- Password dialog -->
  <div id="password-dialog">
    <div class="password-box">
      <h2>Password Required</h2>
      <p>This room is password protected.<br>Room: <span class="room-code" id="password-room-code"></span></p>
      <form id="password-form">
        <div class="password-input-group">
          <input type="text" id="password-input" class="password-input" placeholder="Enter password" autocomplete="off" autofocus>
          <button type="submit" class="password-submit">Join</button>
        </div>
        <div class="password-error" id="password-error"></div>
      </form>
    </div>
  </div>
  
  <!-- Video container -->
  <div id="container">
    <video id="video" autoplay playsinline muted class="scale-fit"></video>
  </div>
  
  <!-- Control bar -->
  <div id="control-bar">
    <button class="control-btn" id="btn-fullscreen" title="Fullscreen (F)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
      </svg>
    </button>
    <button class="control-btn" id="btn-pip" title="Picture-in-Picture (P)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
        <rect x="12" y="9" width="8" height="6" rx="1" fill="currentColor" opacity="0.3"></rect>
      </svg>
    </button>
    <div class="control-divider"></div>
    <div class="scale-selector">
      <button class="scale-btn active" data-scale="fit">Fit</button>
      <button class="scale-btn" data-scale="fill">Fill</button>
      <button class="scale-btn" data-scale="native">Native</button>
    </div>
    <div class="control-divider"></div>
    <button class="control-btn" id="btn-stats" title="Stats (I)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="16" x2="12" y2="12"></line>
        <line x1="12" y1="8" x2="12.01" y2="8"></line>
      </svg>
    </button>
    <button class="control-btn" id="btn-help" title="Keyboard Shortcuts (?)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    </button>
  </div>
  
  <!-- Keyboard shortcuts help -->
  <div id="shortcuts-help">
    <span class="shortcut"><kbd>F</kbd> Fullscreen</span>
    <span class="shortcut"><kbd>P</kbd> Picture-in-Picture</span>
    <span class="shortcut"><kbd>1</kbd><kbd>2</kbd><kbd>3</kbd> Scale</span>
    <span class="shortcut"><kbd>I</kbd> Stats</span>
    <span class="shortcut"><kbd>Esc</kbd> Exit</span>
  </div>
  
  <!-- Stats panel -->
  <div id="stats-panel">
    <div class="stats-title">Connection Stats</div>
    <div class="stats-row">
      <span class="stats-label">Connection</span>
      <span class="stats-value" id="stats-connection-type">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Resolution</span>
      <span class="stats-value" id="stats-resolution">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Frame Rate</span>
      <span class="stats-value" id="stats-framerate">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Bitrate</span>
      <span class="stats-value" id="stats-bitrate">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Latency</span>
      <span class="stats-value" id="stats-latency">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Packets Lost</span>
      <span class="stats-value" id="stats-packets-lost">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Jitter</span>
      <span class="stats-value" id="stats-jitter">--</span>
    </div>
  </div>

  <script>
    // Elements
    const video = document.getElementById('video');
    const container = document.getElementById('container');
    const statusBar = document.getElementById('status-bar');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const roomCodeEl = document.getElementById('room-code');
    const waitingEl = document.getElementById('waiting');
    const waitingTitle = document.getElementById('waiting-title');
    const waitingSubtitle = document.getElementById('waiting-subtitle');
    const waitingRoom = document.getElementById('waiting-room');
    const controlBar = document.getElementById('control-bar');
    const shortcutsHelp = document.getElementById('shortcuts-help');
    const statsPanel = document.getElementById('stats-panel');
    const streamStats = document.getElementById('stream-stats');
    
    // State
    const roomCode = window.location.pathname.substring(1);
    let ws;
    let pc;
    let currentPeerId = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let uiTimeout;
    let statsInterval;
    let lastBytesReceived = 0;
    let lastStatsTime = 0;
    let showStats = false;
    let currentScale = 'fit';
    let roomPassword = ''; // Stored password for reconnection
    
    // Password dialog elements
    const passwordDialog = document.getElementById('password-dialog');
    const passwordForm = document.getElementById('password-form');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    const passwordRoomCode = document.getElementById('password-room-code');
    
    // Initialize
    roomCodeEl.textContent = roomCode;
    waitingRoom.textContent = roomCode;
    passwordRoomCode.textContent = roomCode;
    
    // ICE servers
    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' }
    ];
    
    // UI visibility
    function showUI() {
      document.body.classList.add('show-ui');
      statusBar.classList.add('visible');
      controlBar.classList.add('visible');
      if (showStats) statsPanel.classList.add('visible');
      
      clearTimeout(uiTimeout);
      uiTimeout = setTimeout(hideUI, 3000);
    }
    
    function hideUI() {
      if (document.fullscreenElement || !video.srcObject) return;
      document.body.classList.remove('show-ui');
      statusBar.classList.remove('visible');
      controlBar.classList.remove('visible');
      shortcutsHelp.classList.remove('visible');
      if (!showStats) statsPanel.classList.remove('visible');
    }
    
    // Event listeners for UI visibility
    document.addEventListener('mousemove', showUI);
    document.addEventListener('mousedown', showUI);
    document.addEventListener('keydown', showUI);
    
    // Status updates
    function setStatus(text, state) {
      statusText.textContent = text;
      statusDot.className = 'status-dot ' + state;
      
      // Update waiting screen
      if (state === 'connecting') {
        waitingTitle.textContent = text;
        waitingSubtitle.textContent = 'Please wait...';
      } else if (state === 'error') {
        waitingTitle.textContent = 'Connection Error';
        waitingSubtitle.textContent = text;
      }
    }
    
    function setWaitingState(title, subtitle) {
      waitingTitle.textContent = title;
      waitingSubtitle.textContent = subtitle;
    }
    
    // Fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(e => console.log('Fullscreen error:', e));
      } else {
        document.exitFullscreen();
      }
    }
    
    document.addEventListener('fullscreenchange', () => {
      const btn = document.getElementById('btn-fullscreen');
      if (document.fullscreenElement) {
        btn.classList.add('active');
        showUI();
      } else {
        btn.classList.remove('active');
      }
    });
    
    // Picture-in-Picture
    async function togglePiP() {
      try {
        if (document.pictureInPictureElement) {
          await document.exitPictureInPicture();
        } else if (video.srcObject) {
          await video.requestPictureInPicture();
        }
      } catch (e) {
        console.log('PiP error:', e);
      }
    }
    
    video.addEventListener('enterpictureinpicture', () => {
      document.getElementById('btn-pip').classList.add('active');
    });
    
    video.addEventListener('leavepictureinpicture', () => {
      document.getElementById('btn-pip').classList.remove('active');
    });
    
    // Scale mode
    function setScale(mode) {
      currentScale = mode;
      video.className = 'scale-' + mode;
      
      document.querySelectorAll('.scale-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.scale === mode);
      });
    }
    
    document.querySelectorAll('.scale-btn').forEach(btn => {
      btn.addEventListener('click', () => setScale(btn.dataset.scale));
    });
    
    // Stats toggle
    function toggleStats() {
      showStats = !showStats;
      statsPanel.classList.toggle('visible', showStats);
      document.getElementById('btn-stats').classList.toggle('active', showStats);
    }
    
    // Help toggle
    function toggleHelp() {
      shortcutsHelp.classList.toggle('visible');
      document.getElementById('btn-help').classList.toggle('active', shortcutsHelp.classList.contains('visible'));
    }
    
    // Button event listeners
    document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
    document.getElementById('btn-pip').addEventListener('click', togglePiP);
    document.getElementById('btn-stats').addEventListener('click', toggleStats);
    document.getElementById('btn-help').addEventListener('click', toggleHelp);
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ignore if typing in input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
      
      switch (e.key.toLowerCase()) {
        case 'f':
          toggleFullscreen();
          break;
        case 'p':
          togglePiP();
          break;
        case 'i':
          toggleStats();
          break;
        case '?':
          toggleHelp();
          break;
        case '1':
          setScale('fit');
          break;
        case '2':
          setScale('fill');
          break;
        case '3':
          setScale('native');
          break;
        case 'escape':
          if (document.fullscreenElement) {
            document.exitFullscreen();
          }
          if (document.pictureInPictureElement) {
            document.exitPictureInPicture();
          }
          shortcutsHelp.classList.remove('visible');
          document.getElementById('btn-help').classList.remove('active');
          break;
      }
    });
    
    // Double-click for fullscreen
    video.addEventListener('dblclick', toggleFullscreen);
    
    // Password dialog functions
    function showPasswordDialog(errorText = '') {
      waitingEl.classList.add('hidden');
      passwordDialog.classList.add('visible');
      passwordInput.value = '';
      passwordInput.classList.toggle('error', !!errorText);
      passwordError.textContent = errorText;
      passwordInput.focus();
    }
    
    function hidePasswordDialog() {
      passwordDialog.classList.remove('visible');
      passwordInput.classList.remove('error');
      passwordError.textContent = '';
    }
    
    // Password form submission
    passwordForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const password = passwordInput.value.trim();
      if (!password) {
        passwordInput.classList.add('error');
        passwordError.textContent = 'Please enter a password';
        return;
      }
      
      roomPassword = password;
      hidePasswordDialog();
      waitingEl.classList.remove('hidden');
      
      // Re-send join with password
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'join', role: 'viewer', password: roomPassword }));
      }
    });
    
    // WebRTC Stats collection
    function startStatsCollection() {
      if (statsInterval) clearInterval(statsInterval);
      
      statsInterval = setInterval(async () => {
        if (!pc) return;
        
        try {
          const stats = await pc.getStats();
          let videoStats = null;
          let candidatePairStats = null;
          
          stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'video') {
              videoStats = report;
            }
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              candidatePairStats = report;
            }
          });
          
          if (videoStats) {
            // Resolution
            const res = `${videoStats.frameWidth || '--'}x${videoStats.frameHeight || '--'}`;
            document.getElementById('stat-resolution').textContent = res;
            document.getElementById('stats-resolution').textContent = res;
            
            // Frame rate
            const fps = videoStats.framesPerSecond ? Math.round(videoStats.framesPerSecond) : '--';
            document.getElementById('stat-fps').textContent = fps;
            document.getElementById('stats-framerate').textContent = fps !== '--' ? `${fps} fps` : '--';
            
            // Bitrate calculation
            const now = Date.now();
            const bytesReceived = videoStats.bytesReceived || 0;
            if (lastStatsTime > 0 && lastBytesReceived > 0) {
              const timeDiff = (now - lastStatsTime) / 1000;
              const bytesDiff = bytesReceived - lastBytesReceived;
              const bitrate = (bytesDiff * 8) / timeDiff / 1000; // kbps
              
              let bitrateStr;
              if (bitrate >= 1000) {
                bitrateStr = (bitrate / 1000).toFixed(1) + ' Mbps';
              } else {
                bitrateStr = Math.round(bitrate) + ' kbps';
              }
              document.getElementById('stat-bitrate').textContent = bitrateStr;
              document.getElementById('stats-bitrate').textContent = bitrateStr;
            }
            lastBytesReceived = bytesReceived;
            lastStatsTime = now;
            
            // Packets lost
            const packetsLost = videoStats.packetsLost || 0;
            const packetsReceived = videoStats.packetsReceived || 0;
            const lossPercent = packetsReceived > 0 ? ((packetsLost / (packetsLost + packetsReceived)) * 100).toFixed(1) : 0;
            const lossEl = document.getElementById('stats-packets-lost');
            lossEl.textContent = `${packetsLost} (${lossPercent}%)`;
            lossEl.className = 'stats-value ' + (lossPercent > 5 ? 'bad' : lossPercent > 1 ? 'warn' : 'good');
            
            // Jitter
            const jitter = videoStats.jitter ? (videoStats.jitter * 1000).toFixed(1) + ' ms' : '--';
            document.getElementById('stats-jitter').textContent = jitter;
          }
          
          if (candidatePairStats) {
            // Latency (RTT)
            const rtt = candidatePairStats.currentRoundTripTime;
            const latencyEl = document.getElementById('stats-latency');
            if (rtt !== undefined) {
              const latencyMs = Math.round(rtt * 1000);
              latencyEl.textContent = latencyMs + ' ms';
              latencyEl.className = 'stats-value ' + (latencyMs > 200 ? 'bad' : latencyMs > 100 ? 'warn' : 'good');
            } else {
              latencyEl.textContent = '--';
            }
            
            // Connection type (P2P vs Relay)
            const connTypeEl = document.getElementById('stats-connection-type');
            const localCandidateId = candidatePairStats.localCandidateId;
            let connectionType = 'Unknown';
            
            stats.forEach(report => {
              if (report.type === 'local-candidate' && report.id === localCandidateId) {
                switch (report.candidateType) {
                  case 'relay':
                    connectionType = 'Relay (TURN)';
                    connTypeEl.className = 'stats-value warn';
                    break;
                  case 'host':
                    connectionType = 'Direct (P2P)';
                    connTypeEl.className = 'stats-value good';
                    break;
                  case 'srflx':
                  case 'prflx':
                    connectionType = 'NAT (P2P)';
                    connTypeEl.className = 'stats-value good';
                    break;
                }
              }
            });
            connTypeEl.textContent = connectionType;
          }
        } catch (e) {
          console.log('Stats error:', e);
        }
      }, 1000);
    }
    
    function stopStatsCollection() {
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }
    }
    
    // WebRTC Connection
    async function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/${roomCode}`;
      
      setStatus('Connecting...', 'connecting');
      setWaitingState('Connecting...', 'Establishing connection to server');
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        setStatus('Joining room...', 'connecting');
        setWaitingState('Joining Room', 'Waiting for sharer...');
        reconnectAttempts = 0;
        // Include password if we have one (from previous attempt or reconnection)
        const joinMsg = { type: 'join', role: 'viewer' };
        if (roomPassword) {
          joinMsg.password = roomPassword;
        }
        ws.send(JSON.stringify(joinMsg));
      };
      
      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        
        switch (msg.type) {
          case 'joined':
            setStatus('Waiting for sharer...', 'connecting');
            setWaitingState('Waiting for Sharer', 'The stream will begin when the sharer starts');
            break;
            
          case 'offer':
            currentPeerId = msg.peerId;
            await handleOffer(msg.sdp);
            break;
            
          case 'ice':
            await handleICE(msg.candidate);
            break;
            
          case 'sharer-ready':
            // Sharer has reconnected, clean up old connection and wait for new offer
            setStatus('Sharer reconnected', 'connecting');
            if (pc) {
              pc.close();
              pc = null;
              stopStatsCollection();
            }
            video.srcObject = null;
            streamStats.style.display = 'none';
            setWaitingState('Reconnecting', 'Sharer has reconnected, establishing new stream...');
            waitingEl.classList.remove('hidden');
            break;
            
          case 'password-required':
            // Room requires password
            showPasswordDialog();
            break;
            
          case 'password-invalid':
            // Wrong password
            showPasswordDialog('Invalid password. Please try again.');
            break;
            
          case 'error':
            setStatus(msg.error, 'error');
            // If sharer disconnected, clean up and wait for reconnection
            if (msg.error === 'Sharer disconnected') {
              if (pc) {
                pc.close();
                pc = null;
                stopStatsCollection();
              }
              video.srcObject = null;
              streamStats.style.display = 'none';
              setWaitingState('Sharer Reconnecting', 'Please wait...');
              waitingEl.classList.remove('hidden');
            }
            break;
        }
      };
      
      ws.onclose = () => {
        setStatus('Disconnected', 'error');
        stopStatsCollection();
        attemptReconnect();
      };
      
      ws.onerror = () => {
        setStatus('Connection error', 'error');
      };
    }
    
    function attemptReconnect() {
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000);
        setStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');
        setWaitingState('Reconnecting...', `Attempt ${reconnectAttempts} of ${maxReconnectAttempts}`);
        setTimeout(connect, delay);
      } else {
        setStatus('Failed to connect', 'error');
        setWaitingState('Connection Failed', 'Please refresh the page to try again');
      }
    }
    
    async function handleOffer(sdp) {
      setStatus('Establishing connection...', 'connecting');
      
      if (pc) {
        pc.close();
        pc = null;
        stopStatsCollection();
      }
      
      pc = new RTCPeerConnection({ iceServers });
      
      pc.ontrack = (event) => {
        setStatus('Connected', 'connected');
        waitingEl.classList.add('hidden');
        streamStats.style.display = 'flex';
        video.srcObject = event.streams[0];
        video.play().catch(e => console.log('Autoplay blocked:', e));
        startStatsCollection();
        showUI();
      };
      
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: 'ice',
            peerId: currentPeerId,
            candidate: JSON.stringify(event.candidate)
          }));
        }
      };
      
      pc.oniceconnectionstatechange = () => {
        switch (pc.iceConnectionState) {
          case 'connected':
            setStatus('Connected', 'connected');
            break;
          case 'disconnected':
            setStatus('Reconnecting...', 'connecting');
            break;
          case 'failed':
            setStatus('Connection failed', 'error');
            stopStatsCollection();
            pc.close();
            break;
        }
      };
      
      try {
        await pc.setRemoteDescription({ type: 'offer', sdp });
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        ws.send(JSON.stringify({
          type: 'answer',
          peerId: currentPeerId,
          sdp: answer.sdp
        }));
      } catch (err) {
        console.error('Error handling offer:', err);
        setStatus('Connection error', 'error');
      }
    }
    
    async function handleICE(candidateStr) {
      if (!pc) return;
      try {
        const candidate = JSON.parse(candidateStr);
        await pc.addIceCandidate(candidate);
      } catch (err) {
        console.error('ICE error:', err);
      }
    }
    
    // Start
    connect();
  </script>
</body>
</html>
