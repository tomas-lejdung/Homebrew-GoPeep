<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>GoPeep - Viewing</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --bg-primary: #09090b;
      --bg-secondary: #18181b;
      --bg-tertiary: #27272a;
      --bg-overlay: rgba(9, 9, 11, 0.88);
      --bg-elevated: rgba(39, 39, 42, 0.65);
      --text-primary: #fafafa;
      --text-secondary: #a1a1aa;
      --text-dim: #71717a;
      --accent: #3b82f6;
      --accent-soft: rgba(59, 130, 246, 0.15);
      --accent-glow: rgba(59, 130, 246, 0.4);
      --success: #22c55e;
      --success-soft: rgba(34, 197, 94, 0.15);
      --warning: #f59e0b;
      --warning-soft: rgba(245, 158, 11, 0.15);
      --error: #ef4444;
      --error-soft: rgba(239, 68, 68, 0.15);
      --border: rgba(255, 255, 255, 0.08);
      --border-subtle: rgba(255, 255, 255, 0.04);
      --focus-ring: #3b82f6;
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.4);
      --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.5);
      --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
      --shadow-glow: 0 0 20px rgba(59, 130, 246, 0.15);
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 14px;
      --radius-xl: 20px;
      --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-normal: 250ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
      --transition-bounce: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    body {
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
      overflow: hidden;
      cursor: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    body.show-ui {
      cursor: default;
    }
    
    /* Subtle vignette overlay for depth */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 0%, transparent 60%, rgba(0, 0, 0, 0.3) 100%);
      z-index: 1;
    }
    
    /* Main container - flex column for main + thumbnails */
    #container {
      width: 100vw;
      height: 100vh;
      height: 100dvh; /* Dynamic viewport height - accounts for mobile browser chrome */
      display: flex;
      flex-direction: column;
      background: var(--bg-primary);
      /* Safe area padding for notched devices */
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }
    
    /* Main video area */
    #main-video-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 0;
      position: relative;
      background: radial-gradient(ellipse at center, #111113 0%, var(--bg-primary) 100%);
      overflow: hidden;
    }
    
    #pan-zoom-container {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #pan-zoom-content {
      /* Default (Fit/Fill): fill the viewport */
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Native mode: absolute positioning for pan/zoom */
    #pan-zoom-content.native-mode {
      position: absolute;
      top: 0;
      left: 0;
      width: auto;
      height: auto;
      display: block;
      /* All positioning handled via JS transform */
    }
    
    .main-video {
      background: transparent;
      outline: none;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      transition: opacity 0.2s ease;
    }
    
    .main-video.scale-fit {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      object-fit: contain;
    }
    
    .main-video.scale-fill {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .main-video.scale-native {
      width: auto;
      height: auto;
      max-width: none;
      max-height: none;
      display: block;
      margin: 0;
      padding: 0;
    }
    
    /* Thumbnails bar */
    #thumbnails-bar {
      display: none;
      min-height: 110px;
      background: linear-gradient(to top, var(--bg-secondary) 0%, rgba(24, 24, 27, 0.95) 100%);
      border-top: 1px solid var(--border-subtle);
      padding: 12px 24px;
      padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
      gap: 12px;
      align-items: center;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--bg-tertiary) transparent;
      z-index: 10;
    }
    
    #thumbnails-bar::-webkit-scrollbar {
      height: 4px;
    }
    
    #thumbnails-bar::-webkit-scrollbar-track {
      background: transparent;
    }
    
    #thumbnails-bar::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 2px;
    }
    
    #thumbnails-bar.visible {
      display: flex;
    }
    
    .thumbnail-container {
      position: relative;
      flex-shrink: 0;
      cursor: pointer;
      border-radius: var(--radius-md);
      overflow: hidden;
      border: 2px solid var(--border);
      background: var(--bg-primary);
      transition: all var(--transition-normal);
      box-shadow: var(--shadow-sm);
    }
    
    .thumbnail-container:hover {
      border-color: rgba(59, 130, 246, 0.5);
      transform: translateY(-2px) scale(1.02);
      box-shadow: var(--shadow-md), 0 0 20px rgba(59, 130, 246, 0.1);
    }
    
    .thumbnail-container.focused {
      border-color: var(--success);
      box-shadow: var(--shadow-md), 0 0 16px rgba(34, 197, 94, 0.2);
    }
    
    .thumbnail-container.active {
      border-color: var(--accent);
      box-shadow: var(--shadow-md), var(--shadow-glow);
    }
    
    .thumbnail-video {
      width: 142px;
      height: 80px;
      object-fit: cover;
      background: var(--bg-primary);
      display: block;
    }
    
    .thumbnail-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 6px 10px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.6) 60%, transparent 100%);
      font-size: 10px;
      font-weight: 500;
      color: var(--text-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: 0.01em;
    }
    
    .thumbnail-container.focused .thumbnail-label {
      color: var(--success);
    }
    
    .thumbnail-container.active .thumbnail-label {
      color: var(--text-primary);
    }
    
    .thumbnail-focus-indicator {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      display: none;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .thumbnail-container.focused .thumbnail-focus-indicator {
      display: block;
    }
    
    @keyframes pulse-glow {
      0%, 100% { opacity: 1; box-shadow: 0 0 8px rgba(34, 197, 94, 0.6); }
      50% { opacity: 0.7; box-shadow: 0 0 12px rgba(34, 197, 94, 0.8); }
    }
    
    /* Grid Layout System */
    #video-grid {
      display: none;
      flex: 1;
      width: 100%;
      min-height: 0;
      gap: 4px;
      padding: 4px;
      background: var(--bg-primary);
    }
    
    #video-grid.visible {
      display: grid;
    }
    
    /* Grid layouts based on stream count */
    #video-grid.grid-1 {
      grid-template-columns: 1fr;
      grid-template-rows: 1fr;
    }
    
    #video-grid.grid-2 {
      grid-template-columns: var(--col-1, 1fr) var(--col-2, 1fr);
      grid-template-rows: 1fr;
    }
    
    #video-grid.grid-3 {
      grid-template-columns: var(--col-1, 1fr) var(--col-2, 1fr);
      grid-template-rows: var(--row-1, 1fr) var(--row-2, 1fr);
    }
    
    #video-grid.grid-3 .grid-cell:first-child {
      grid-row: span 2;
    }
    
    #video-grid.grid-4 {
      grid-template-columns: var(--col-1, 1fr) var(--col-2, 1fr);
      grid-template-rows: var(--row-1, 1fr) var(--row-2, 1fr);
    }
    
    /* Equal sizing mode */
    #video-grid.equal-size {
      --col-1: 1fr;
      --col-2: 1fr;
      --row-1: 1fr;
      --row-2: 1fr;
    }
    
    .grid-cell {
      position: relative;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      overflow: hidden;
      cursor: pointer;
      transition: all var(--transition-fast);
      border: 2px solid transparent;
    }
    
    .grid-cell:hover {
      border-color: rgba(59, 130, 246, 0.4);
    }
    
    .grid-cell.selected {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
    }
    
    .grid-cell.sharer-focused {
      border-color: var(--success);
    }
    
    .grid-cell.sharer-focused::before {
      content: '';
      position: absolute;
      top: 8px;
      right: 8px;
      width: 10px;
      height: 10px;
      background: var(--success);
      border-radius: 50%;
      z-index: 10;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .grid-cell video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: transparent;
    }
    
    .grid-cell-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0.4) 70%, transparent 100%);
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      opacity: 0;
      transition: opacity var(--transition-fast);
      pointer-events: none;
    }
    
    .grid-cell:hover .grid-cell-label,
    .grid-cell.selected .grid-cell-label {
      opacity: 1;
    }
    
    /* Row Layout Mode */
    #video-row {
      display: none;
      flex: 1;
      width: 100%;
      min-height: 0;
      overflow-x: auto;
      overflow-y: auto;
      background: var(--bg-primary);
      -webkit-overflow-scrolling: touch;
      cursor: grab;
      position: relative;
    }
    
    #video-row.dragging {
      cursor: grabbing;
      user-select: none;
    }
    
    #video-row.visible {
      display: flex;
      align-items: flex-start; /* Start at top so tall content is scrollable */
      gap: 8px;
      padding: 8px;
      padding-top: 60px; /* Space for header */
      padding-left: calc(8px + env(safe-area-inset-left, 0px));
      padding-right: calc(8px + env(safe-area-inset-right, 0px));
    }
    
    #video-row::-webkit-scrollbar {
      height: 6px;
    }
    
    #video-row::-webkit-scrollbar-track {
      background: var(--bg-secondary);
      border-radius: 3px;
    }
    
    #video-row::-webkit-scrollbar-thumb {
      background: var(--bg-tertiary);
      border-radius: 3px;
    }
    
    #video-row::-webkit-scrollbar-thumb:hover {
      background: var(--text-dim);
    }
    
    .row-cell {
      position: relative;
      flex-shrink: 0;
      background: var(--bg-secondary);
      border-radius: var(--radius-md);
      overflow: hidden;
      cursor: pointer;
      transition: all var(--transition-fast);
      border: 2px solid transparent;
      scroll-snap-align: center;
      margin-top: auto;
      margin-bottom: auto; /* Centers vertically when smaller than container, stays scrollable when larger */
    }
    
    .row-cell:hover {
      border-color: rgba(59, 130, 246, 0.4);
    }
    
    .row-cell.selected {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
    }
    
    .row-cell.sharer-focused {
      border-color: var(--success);
    }
    
    .row-cell.sharer-focused::before {
      content: '';
      position: absolute;
      top: 8px;
      right: 8px;
      width: 10px;
      height: 10px;
      background: var(--success);
      border-radius: 50%;
      z-index: 10;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    .row-cell video {
      display: block;
      background: transparent;
      /* Native size - no object-fit scaling */
    }
    
    .row-cell-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 8px 12px;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0.4) 70%, transparent 100%);
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      /* Always visible in row mode for orientation */
      opacity: 1;
    }
    
    .row-cell.sharer-focused .row-cell-label {
      color: var(--success);
    }
    
    .row-cell.selected .row-cell-label {
      color: var(--text-primary);
    }
    
    /* Row scroll indicator */
    .row-scroll-hint {
      position: absolute;
      bottom: 50%;
      transform: translateY(50%);
      width: 40px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(to right, var(--bg-primary) 0%, transparent 100%);
      color: var(--text-dim);
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--transition-normal);
      z-index: 20;
    }
    
    .row-scroll-hint.right {
      right: 0;
      background: linear-gradient(to left, var(--bg-primary) 0%, transparent 100%);
    }
    
    .row-scroll-hint.left {
      left: 0;
    }
    
    #video-row.can-scroll-right .row-scroll-hint.right,
    #video-row.can-scroll-left .row-scroll-hint.left {
      opacity: 0.7;
    }
    
    /* Row minimap */
    .row-minimap {
      position: fixed;
      bottom: calc(90px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%);
      height: 48px;
      max-width: 80vw;
      background: var(--bg-overlay);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: var(--radius-md);
      border: 1px solid var(--border);
      padding: 6px;
      display: none;
      align-items: center;
      gap: 4px;
      z-index: 100;
      box-shadow: var(--shadow-lg);
      overflow-x: auto;
      cursor: pointer;
    }
    
    .row-minimap.visible {
      display: flex;
    }
    
    .row-minimap::-webkit-scrollbar {
      display: none;
    }
    
    .row-minimap-item {
      flex-shrink: 0;
      height: 36px;
      background: var(--bg-secondary);
      border-radius: 4px;
      overflow: hidden;
      border: 2px solid transparent;
      transition: all var(--transition-fast);
      cursor: pointer;
      position: relative;
    }
    
    .row-minimap-item:hover {
      border-color: rgba(59, 130, 246, 0.4);
    }
    
    .row-minimap-item.in-view {
      border-color: var(--accent);
    }
    
    .row-minimap-item.sharer-focused::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 2px;
      width: 6px;
      height: 6px;
      background: var(--success);
      border-radius: 50%;
    }
    
    .row-minimap-item canvas {
      height: 100%;
      width: auto;
      display: block;
    }
    
    .row-minimap-viewport {
      position: absolute;
      top: 0;
      height: 100%;
      background: rgba(59, 130, 246, 0.1);
      border-left: 2px solid var(--accent);
      border-right: 2px solid var(--accent);
      pointer-events: none;
      display: none;
    }
    
    /* Layout selector */
    .layout-selector {
      display: none;
      align-items: center;
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-sm);
      padding: 3px;
      gap: 2px;
    }
    
    .layout-selector.visible {
      display: flex;
    }
    
    .layout-btn {
      width: 34px;
      height: 34px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
    }
    
    .layout-btn:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.04);
    }
    
    .layout-btn.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    
    .layout-btn svg {
      width: 18px;
      height: 18px;
    }
    
    /* Proportional toggle */
    .proportional-toggle {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 0 8px;
      font-size: 11px;
      color: var(--text-dim);
    }
    
    .proportional-toggle.visible {
      display: flex;
    }
    
    .follow-toggle {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 0 8px;
      font-size: 11px;
      color: var(--text-dim);
    }
    
    .follow-toggle.visible {
      display: flex;
    }
    
    .toggle-switch {
      position: relative;
      width: 36px;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      cursor: pointer;
      transition: background var(--transition-fast);
    }
    
    .toggle-switch.active {
      background: var(--accent);
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      transition: transform var(--transition-fast);
      box-shadow: var(--shadow-sm);
    }
    
    .toggle-switch.active::after {
      transform: translateX(16px);
    }
    
    /* Pan/Zoom container for Native view */
    .pan-zoom-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      cursor: grab;
    }
    
    .pan-zoom-container.panning {
      cursor: grabbing;
    }
    
    .pan-zoom-container.can-pan {
      cursor: grab;
    }
    
    .pan-zoom-content {
      /* Base styles - positioning controlled by ID selectors */
      transform-origin: 0 0;
      transition: none;
    }
    
    .pan-zoom-content.animating {
      transition: transform 0.2s ease-out;
    }
    
    /* Minimap */
    .minimap {
      position: absolute;
      bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      right: calc(16px + env(safe-area-inset-right, 0px));
      width: 120px;
      background: var(--bg-overlay);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      overflow: hidden;
      opacity: 0;
      transform: scale(0.9);
      transition: all var(--transition-normal);
      pointer-events: none;
      z-index: 50;
    }
    
    .minimap.visible {
      opacity: 1;
      transform: scale(1);
    }
    
    .minimap-content {
      position: relative;
      width: 100%;
    }
    
    .minimap-image {
      width: 100%;
      height: auto;
      display: block;
      opacity: 0.6;
    }
    
    .minimap-viewport {
      position: absolute;
      border: 2px solid var(--accent);
      background: rgba(59, 130, 246, 0.15);
      border-radius: 2px;
      pointer-events: none;
    }
    
    /* Mobile-specific styles */
    @media (max-width: 768px) {
      #video-grid {
        gap: 2px;
        padding: 2px;
      }
      
      .grid-cell {
        border-radius: var(--radius-sm);
      }
      
      .grid-cell-label {
        font-size: 10px;
        padding: 6px 8px;
        opacity: 1;
      }
      
      #control-bar {
        padding: 6px 10px;
        gap: 4px;
        flex-wrap: wrap;
        justify-content: center;
        max-width: calc(100vw - 24px);
        left: 12px;
        right: 12px;
        transform: translateY(100px);
      }
      
      #control-bar.visible {
        transform: translateY(0);
      }
      
      .control-btn {
        width: 38px;
        height: 38px;
      }
      
      .layout-btn {
        width: 30px;
        height: 30px;
      }
      
      .scale-btn {
        padding: 6px 10px;
        font-size: 10px;
      }
      
      .proportional-toggle,
      .follow-toggle {
        font-size: 10px;
        padding: 0 6px;
      }
      
      .toggle-switch {
        width: 32px;
        height: 18px;
      }
      
      .toggle-switch::after {
        width: 14px;
        height: 14px;
      }
      
      .toggle-switch.active::after {
        transform: translateX(14px);
      }
      
      .control-divider {
        height: 24px;
        margin: 0 4px;
      }
      
      .minimap {
        width: 100px;
        bottom: 12px;
        right: 12px;
      }
      
      /* Force focus layout on very small screens */
      @media (max-width: 480px) {
        #video-grid.grid-3,
        #video-grid.grid-4 {
          grid-template-columns: 1fr;
          grid-template-rows: repeat(auto-fit, minmax(150px, 1fr));
        }
        
        #video-grid.grid-3 .grid-cell:first-child {
          grid-row: span 1;
        }
        
        /* Hide toggle labels on very small screens */
        .proportional-toggle span,
        .follow-toggle span {
          display: none;
        }
        
        .proportional-toggle,
        .follow-toggle {
          padding: 0 4px;
        }
        
        .scale-btn {
          padding: 6px 8px;
        }
      }
    }
    
    /* Landscape mobile */
    @media (max-width: 768px) and (orientation: landscape) {
      #video-grid.grid-2 {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    /* Top status bar - compact floating pill */
    #status-bar {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 8px 12px;
      background: rgba(9, 9, 11, 0.5);
      backdrop-filter: blur(12px) saturate(150%);
      -webkit-backdrop-filter: blur(12px) saturate(150%);
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
      z-index: 100;
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity var(--transition-normal), transform var(--transition-normal);
      border-radius: var(--radius-lg);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: var(--shadow-md);
    }

    #status-bar.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .status-section {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .status-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 100px;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }
    
    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
      flex-shrink: 0;
      transition: all var(--transition-normal);
    }
    
    .status-dot.connecting {
      background: var(--warning);
      box-shadow: 0 0 8px var(--warning);
      animation: status-pulse 1.5s ease-in-out infinite;
    }
    
    .status-dot.connected {
      background: var(--success);
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }
    
    .status-dot.degraded {
      background: var(--warning);
      box-shadow: 0 0 8px rgba(245, 158, 11, 0.5);
    }
    
    .status-dot.error {
      background: var(--error);
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
    
    @keyframes status-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(0.85); }
    }
    
    #status-text {
      font-weight: 500;
      font-size: 11px;
      letter-spacing: 0.01em;
    }
    
    #room-code {
      font-family: "SF Mono", Monaco, "Cascadia Code", "Consolas", monospace;
      font-weight: 600;
      color: var(--accent);
      font-size: 12px;
      padding: 3px 8px;
      background: rgba(59, 130, 246, 0.1);
      border-radius: var(--radius-sm);
      border: 1px solid rgba(59, 130, 246, 0.15);
      letter-spacing: 0.05em;
    }
    
    .divider {
      width: 1px;
      height: 24px;
      background: var(--border);
      opacity: 0.5;
    }
    
    .stat-label {
      color: var(--text-dim);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
    }
    
    .stat-value {
      color: var(--text-primary);
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      font-size: 12px;
      font-weight: 500;
    }
    
    #status-right {
      display: none;  /* Hidden for compact header - stats available via panel */
    }
    
    #stream-count {
      display: none;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: var(--bg-elevated);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      font-size: 12px;
      font-weight: 500;
    }
    
    #stream-count svg {
      opacity: 0.7;
    }
    
    #stream-count.visible {
      display: flex;
    }
    
    /* Stream stats in status bar - hidden for compact header */
    #stream-stats {
      display: none !important;  /* Stats available via panel (I key) */
    }
    
    /* Control bar */
    #control-bar {
      position: fixed;
      bottom: calc(28px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      padding: 8px 12px;
      background: var(--bg-overlay);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border-radius: var(--radius-xl);
      display: flex;
      align-items: center;
      gap: 4px;
      z-index: 100;
      opacity: 0;
      transition: opacity var(--transition-normal), transform var(--transition-bounce);
      border: 1px solid var(--border);
      box-shadow: var(--shadow-lg), 0 0 0 1px rgba(255, 255, 255, 0.03) inset;
    }
    
    #control-bar.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    /* Adjust control bar position when thumbnails visible */
    body.multi-stream #control-bar {
      bottom: calc(134px + env(safe-area-inset-bottom, 0px));
    }
    
    .control-btn {
      width: 42px;
      height: 42px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      border-radius: var(--radius-md);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all var(--transition-fast);
      position: relative;
      overflow: hidden;
    }
    
    .control-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, rgba(255, 255, 255, 0.15) 0%, transparent 70%);
      opacity: 0;
      transition: opacity var(--transition-fast);
    }
    
    .control-btn:hover {
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.08);
    }
    
    .control-btn:hover::before {
      opacity: 1;
    }
    
    .control-btn:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.12);
    }
    
    .control-btn.active {
      color: var(--accent);
      background: var(--accent-soft);
    }
    
    .control-btn svg {
      width: 20px;
      height: 20px;
      position: relative;
      z-index: 1;
    }
    
    .control-divider {
      width: 1px;
      height: 28px;
      background: var(--border);
      margin: 0 6px;
      opacity: 0.6;
    }
    
    /* Scale mode selector */
    .scale-selector {
      display: flex;
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-sm);
      padding: 3px;
      gap: 2px;
    }
    
    .scale-btn {
      padding: 7px 14px;
      border: none;
      background: transparent;
      color: var(--text-dim);
      font-size: 11px;
      font-weight: 600;
      border-radius: 5px;
      cursor: pointer;
      transition: all var(--transition-fast);
      letter-spacing: 0.02em;
    }
    
    .scale-btn:hover {
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.04);
    }
    
    .scale-btn.active {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
    }
    
    /* Waiting screen */
    #waiting {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg-primary);
      z-index: 50;
      animation: waiting-fade-in 0.5s ease-out;
    }
    
    @keyframes waiting-fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    #waiting.hidden {
      display: none;
    }
    
    .spinner-container {
      position: relative;
      width: 64px;
      height: 64px;
      margin-bottom: 32px;
    }
    
    .spinner {
      width: 64px;
      height: 64px;
      border: 2px solid var(--border);
      border-radius: 50%;
      position: absolute;
      inset: 0;
    }
    
    .spinner::before {
      content: '';
      position: absolute;
      inset: -2px;
      border: 2px solid transparent;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s cubic-bezier(0.4, 0, 0.2, 1) infinite;
    }
    
    .spinner::after {
      content: '';
      position: absolute;
      inset: 6px;
      border: 2px solid transparent;
      border-top-color: rgba(59, 130, 246, 0.4);
      border-radius: 50%;
      animation: spin 1.5s cubic-bezier(0.4, 0, 0.2, 1) infinite reverse;
    }
    
    .spinner-glow {
      position: absolute;
      inset: -8px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--accent-glow) 0%, transparent 70%);
      animation: glow-pulse 2s ease-in-out infinite;
      filter: blur(8px);
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @keyframes glow-pulse {
      0%, 100% { opacity: 0.4; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
    }
    
    #waiting h2 {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--text-primary);
      letter-spacing: -0.01em;
    }
    
    #waiting p {
      color: var(--text-dim);
      font-size: 14px;
      font-weight: 400;
    }
    
    #waiting-room {
      margin-top: 28px;
      padding: 14px 24px;
      background: var(--accent-soft);
      border: 1px solid rgba(59, 130, 246, 0.25);
      border-radius: var(--radius-md);
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      color: var(--accent);
      font-size: 18px;
      font-weight: 600;
      letter-spacing: 0.1em;
      box-shadow: 0 0 24px rgba(59, 130, 246, 0.1);
    }
    
    /* Keyboard shortcuts help */
    #shortcuts-help {
      position: fixed;
      bottom: calc(90px + env(safe-area-inset-bottom, 0px));
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 14px 24px;
      background: var(--bg-overlay);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-radius: var(--radius-lg);
      font-size: 12px;
      color: var(--text-secondary);
      opacity: 0;
      transition: all var(--transition-normal);
      pointer-events: none;
      border: 1px solid var(--border);
      z-index: 99;
      box-shadow: var(--shadow-md);
    }
    
    #shortcuts-help.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }
    
    body.multi-stream #shortcuts-help {
      bottom: calc(200px + env(safe-area-inset-bottom, 0px));
    }
    
    .shortcut {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
      font-size: 11px;
    }
    
    .shortcut + .shortcut {
      margin-left: 18px;
      padding-left: 18px;
      border-left: 1px solid var(--border);
    }
    
    kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 22px;
      height: 22px;
      padding: 0 6px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--border);
      border-radius: 5px;
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      font-size: 10px;
      font-weight: 600;
      color: var(--text-primary);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    
    /* Stats panel */
    #stats-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      padding: 16px 18px;
      background: var(--bg-overlay);
      backdrop-filter: blur(24px) saturate(180%);
      -webkit-backdrop-filter: blur(24px) saturate(180%);
      border-radius: var(--radius-lg);
      font-size: 12px;
      opacity: 0;
      transform: translateX(20px) scale(0.95);
      transition: all var(--transition-normal);
      pointer-events: none;
      border: 1px solid var(--border);
      z-index: 100;
      min-width: 200px;
      box-shadow: var(--shadow-lg);
    }
    
    #stats-panel.visible {
      opacity: 1;
      transform: translateX(0) scale(1);
      pointer-events: auto;
    }
    
    .stats-title {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-dim);
      margin-bottom: 14px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border-subtle);
    }
    
    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
    }
    
    .stats-row + .stats-row {
      border-top: 1px solid var(--border-subtle);
    }
    
    .stats-label {
      color: var(--text-dim);
      font-size: 11px;
      font-weight: 500;
    }
    
    .stats-value {
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      color: var(--text-primary);
      font-size: 12px;
      font-weight: 500;
      padding: 2px 6px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 4px;
    }
    
    .stats-value.good { 
      color: var(--success); 
      background: var(--success-soft);
    }
    .stats-value.warn { 
      color: var(--warning); 
      background: var(--warning-soft);
    }
    .stats-value.bad { 
      color: var(--error); 
      background: var(--error-soft);
    }
    
    /* Password dialog */
    #password-dialog {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(9, 9, 11, 0.95);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 200;
    }
    
    #password-dialog.visible {
      display: flex;
      animation: dialog-fade-in 0.3s ease-out;
    }
    
    @keyframes dialog-fade-in {
      from { 
        opacity: 0; 
      }
      to { 
        opacity: 1; 
      }
    }
    
    .password-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: var(--radius-xl);
      padding: 40px;
      text-align: center;
      max-width: 420px;
      width: 90%;
      box-shadow: var(--shadow-lg), 0 0 80px rgba(0, 0, 0, 0.5);
      animation: dialog-box-in 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    @keyframes dialog-box-in {
      from { 
        opacity: 0; 
        transform: scale(0.9) translateY(20px); 
      }
      to { 
        opacity: 1; 
        transform: scale(1) translateY(0); 
      }
    }
    
    .password-box h2 {
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 8px;
      letter-spacing: -0.02em;
    }
    
    .password-box p {
      color: var(--text-secondary);
      font-size: 14px;
      margin-bottom: 28px;
      line-height: 1.5;
    }
    
    .password-box .room-code {
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      color: var(--accent);
      font-weight: 600;
      background: var(--accent-soft);
      padding: 2px 8px;
      border-radius: 4px;
    }
    
    .password-input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }
    
    .password-input {
      flex: 1;
      padding: 14px 18px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      color: var(--text-primary);
      font-size: 16px;
      font-family: "SF Mono", Monaco, "Cascadia Code", monospace;
      outline: none;
      transition: all var(--transition-fast);
    }
    
    .password-input::placeholder {
      color: var(--text-dim);
    }
    
    .password-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-soft);
    }
    
    .password-input.error {
      border-color: var(--error);
      box-shadow: 0 0 0 3px var(--error-soft);
    }
    
    .password-submit {
      padding: 14px 28px;
      background: var(--accent);
      border: none;
      border-radius: var(--radius-md);
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }
    
    .password-submit:hover {
      background: #2563eb;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    
    .password-submit:active {
      transform: translateY(0);
    }
    
    .password-error {
      color: var(--error);
      font-size: 13px;
      height: 20px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <!-- Top status bar -->
  <div id="status-bar">
    <div class="status-pill">
      <div class="status-dot connecting" id="status-dot"></div>
      <span id="status-text">Connecting...</span>
    </div>
    <span id="room-code"></span>
    <div id="stream-stats" style="display: none;">
      <div class="status-section">
        <span class="stat-label">RES</span>
        <span class="stat-value" id="stat-resolution">--</span>
      </div>
      <div class="status-section">
        <span class="stat-label">FPS</span>
        <span class="stat-value" id="stat-fps">--</span>
      </div>
      <div class="status-section">
        <span class="stat-label">BITRATE</span>
        <span class="stat-value" id="stat-bitrate">--</span>
      </div>
    </div>
    <div id="status-right">
      <div id="stream-count">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
          <line x1="8" y1="21" x2="16" y2="21"></line>
          <line x1="12" y1="17" x2="12" y2="21"></line>
        </svg>
        <span id="stream-count-text">1</span>
      </div>
    </div>
  </div>
  
  <!-- Waiting screen -->
  <div id="waiting">
    <div class="spinner-container">
      <div class="spinner-glow"></div>
      <div class="spinner"></div>
    </div>
    <h2 id="waiting-title">Connecting...</h2>
    <p id="waiting-subtitle">Establishing connection to sharer</p>
    <div id="waiting-room"></div>
  </div>
  
  <!-- Password dialog -->
  <div id="password-dialog">
    <div class="password-box">
      <h2>Password Required</h2>
      <p>This room is password protected.<br>Room: <span class="room-code" id="password-room-code"></span></p>
      <form id="password-form">
        <div class="password-input-group">
          <input type="text" id="password-input" class="password-input" placeholder="Enter password" autocomplete="off" autofocus>
          <button type="submit" class="password-submit">Join</button>
        </div>
        <div class="password-error" id="password-error"></div>
      </form>
    </div>
  </div>
  
  <!-- Video container -->
  <div id="container">
    <!-- Main video area (Focus mode) -->
    <div id="main-video-container">
      <div class="pan-zoom-container" id="pan-zoom-container">
        <div class="pan-zoom-content" id="pan-zoom-content">
          <video id="main-video" class="main-video scale-fit" autoplay playsinline muted></video>
        </div>
      </div>
      <!-- Minimap for panning -->
      <div class="minimap" id="minimap">
        <div class="minimap-content">
          <canvas class="minimap-image" id="minimap-canvas"></canvas>
          <div class="minimap-viewport" id="minimap-viewport"></div>
        </div>
      </div>
    </div>
    
    <!-- Grid view (Grid mode) -->
    <div id="video-grid"></div>
    
    <!-- Row view (Row mode) -->
    <div id="video-row"></div>
    
    <!-- Row minimap navigation -->
    <div class="row-minimap" id="row-minimap"></div>
    
    <!-- Thumbnails bar for multi-stream (Focus mode only) -->
    <div id="thumbnails-bar"></div>
  </div>
  
  <!-- Control bar -->
  <div id="control-bar">
    <button class="control-btn" id="btn-fullscreen" title="Fullscreen (F)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
      </svg>
    </button>
    <button class="control-btn" id="btn-pip" title="Picture-in-Picture (P)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect>
        <rect x="12" y="9" width="8" height="6" rx="1" fill="currentColor" opacity="0.3"></rect>
      </svg>
    </button>
    <div class="control-divider"></div>
    <!-- Layout selector (visible when multiple streams) -->
    <div class="layout-selector" id="layout-selector">
      <button class="layout-btn active" data-layout="focus" title="Focus View">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2"></rect>
        </svg>
      </button>
      <button class="layout-btn" data-layout="grid" title="Grid View">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="8" height="8" rx="1"></rect>
          <rect x="13" y="3" width="8" height="8" rx="1"></rect>
          <rect x="3" y="13" width="8" height="8" rx="1"></rect>
          <rect x="13" y="13" width="8" height="8" rx="1"></rect>
        </svg>
      </button>
      <button class="layout-btn" data-layout="row" title="Row View">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="2" y="6" width="6" height="12" rx="1"></rect>
          <rect x="9" y="6" width="6" height="12" rx="1"></rect>
          <rect x="16" y="6" width="6" height="12" rx="1"></rect>
        </svg>
      </button>
    </div>
    <!-- Proportional toggle (visible in grid mode) -->
    <div class="proportional-toggle" id="proportional-toggle">
      <span>Auto-size</span>
      <div class="toggle-switch active" id="proportional-switch" title="Toggle proportional sizing (E)"></div>
    </div>
    <!-- Follow toggle (visible in multi-stream mode) -->
    <div class="follow-toggle" id="follow-toggle">
      <span>Follow</span>
      <div class="toggle-switch active" id="follow-switch" title="Auto-follow sharer's focused window"></div>
    </div>
    <div class="control-divider" id="layout-divider" style="display: none;"></div>
    <div class="scale-selector">
      <button class="scale-btn active" data-scale="fit">Fit</button>
      <button class="scale-btn" data-scale="fill">Fill</button>
      <button class="scale-btn" data-scale="native">Native</button>
    </div>
    <div class="control-divider"></div>
    <button class="control-btn" id="btn-stats" title="Stats (I)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="12" y1="16" x2="12" y2="12"></line>
        <line x1="12" y1="8" x2="12.01" y2="8"></line>
      </svg>
    </button>
    <button class="control-btn" id="btn-help" title="Keyboard Shortcuts (?)">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    </button>
  </div>
  
  <!-- Keyboard shortcuts help -->
  <div id="shortcuts-help">
    <span class="shortcut"><kbd>F</kbd>Fullscreen</span>
    <span class="shortcut"><kbd>P</kbd>PiP</span>
    <span class="shortcut"><kbd>G</kbd>Layout</span>
    <span class="shortcut"><kbd>E</kbd>Auto-size</span>
    <span class="shortcut"><kbd>1</kbd><kbd>2</kbd><kbd>3</kbd>Scale</span>
    <span class="shortcut"><kbd>I</kbd>Stats</span>
  </div>
  
  <!-- Stats panel -->
  <div id="stats-panel">
    <div class="stats-title">Connection Stats</div>
    <div class="stats-row">
      <span class="stats-label">Connection</span>
      <span class="stats-value" id="stats-connection-type">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Resolution</span>
      <span class="stats-value" id="stats-resolution">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Frame Rate</span>
      <span class="stats-value" id="stats-framerate">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Bitrate</span>
      <span class="stats-value" id="stats-bitrate">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Latency</span>
      <span class="stats-value" id="stats-latency">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Packets Lost</span>
      <span class="stats-value" id="stats-packets-lost">--</span>
    </div>
    <div class="stats-row">
      <span class="stats-label">Jitter</span>
      <span class="stats-value" id="stats-jitter">--</span>
    </div>
  </div>

  <script>
    // Elements
    const mainVideo = document.getElementById('main-video');
    const mainVideoContainer = document.getElementById('main-video-container');
    const thumbnailsBar = document.getElementById('thumbnails-bar');
    const statusBar = document.getElementById('status-bar');
    const statusDot = document.getElementById('status-dot');
    const statusText = document.getElementById('status-text');
    const roomCodeEl = document.getElementById('room-code');
    const waitingEl = document.getElementById('waiting');
    const waitingTitle = document.getElementById('waiting-title');
    const waitingSubtitle = document.getElementById('waiting-subtitle');
    const waitingRoom = document.getElementById('waiting-room');
    const controlBar = document.getElementById('control-bar');
    const shortcutsHelp = document.getElementById('shortcuts-help');
    const statsPanel = document.getElementById('stats-panel');
    const streamStats = document.getElementById('stream-stats');
    const streamCountEl = document.getElementById('stream-count');
    const streamCountText = document.getElementById('stream-count-text');
    
    // Layout elements
    const videoGrid = document.getElementById('video-grid');
    const layoutSelector = document.getElementById('layout-selector');
    const proportionalToggle = document.getElementById('proportional-toggle');
    const proportionalSwitch = document.getElementById('proportional-switch');
    const followToggle = document.getElementById('follow-toggle');
    const followSwitch = document.getElementById('follow-switch');
    const layoutDivider = document.getElementById('layout-divider');
    const panZoomContainer = document.getElementById('pan-zoom-container');
    const panZoomContent = document.getElementById('pan-zoom-content');
    const minimap = document.getElementById('minimap');
    const minimapCanvas = document.getElementById('minimap-canvas');
    const minimapViewport = document.getElementById('minimap-viewport');
    const videoRow = document.getElementById('video-row');
    const rowMinimap = document.getElementById('row-minimap');
    
    // State
    const roomCode = window.location.pathname.substring(1);
    let ws;
    let pc;
    let currentPeerId = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let uiTimeout;
    let statsInterval;
    let lastBytesReceived = 0;
    let lastStatsTime = 0;
    let showStats = false;
    let currentScale = 'fit';
    let roomPassword = '';
    
    // Multi-stream state
    let streams = {}; // index (0,1,2,3) -> { stream, browserTrackId, info }
    let streamOrder = []; // Array of stream indices in order received
    let streamsInfo = []; // Info from sharer (video0, video1, etc.)
    let viewerFocusedIndex = null; // What the viewer has selected (index)
    let sharerFocusedIndex = null; // What the sharer has focused (index from OS)
    
    // Layout state
    let currentLayout = 'focus'; // 'focus', 'grid', or 'row'
    let proportionalSizing = true; // true = auto-size based on resolution, false = equal size
    let followMode = true; // true = auto-follow sharer's focused window
    let gridCells = {}; // index -> { cell, video, label }
    let rowCells = {}; // index -> { cell, video, label } for row mode
    let selectedGridIndex = null; // Currently selected stream in grid/row mode
    
    // Pan/zoom state
    let panZoomState = {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isPanning: false,
      startX: 0,
      startY: 0,
      lastX: 0,
      lastY: 0
    };
    let canPan = false; // True when content is larger than viewport
    let minimapUpdateInterval = null;

    // Cursor following state
    let cursorFollowState = {
      targetX: 0,           // Target pan X position
      targetY: 0,           // Target pan Y position
      cursorInView: false,
      animating: false,
      animationId: null
    };
    const CURSOR_SMOOTH_FACTOR = 0.15;  // Lerp factor (higher = faster)
    const CURSOR_SNAP_THRESHOLD = 0.5;  // Stop animating below this distance
    
    // Password dialog elements
    const passwordDialog = document.getElementById('password-dialog');
    const passwordForm = document.getElementById('password-form');
    const passwordInput = document.getElementById('password-input');
    const passwordError = document.getElementById('password-error');
    const passwordRoomCode = document.getElementById('password-room-code');
    
    // Initialize
    console.log('GoPeep Viewer initializing...');
    console.log('Room code:', roomCode);
    roomCodeEl.textContent = roomCode;
    waitingRoom.textContent = roomCode;
    passwordRoomCode.textContent = roomCode;
    
    // ICE servers
    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' }
    ];
    
    // UI visibility
    function showUI() {
      document.body.classList.add('show-ui');
      statusBar.classList.add('visible');
      controlBar.classList.add('visible');
      if (showStats) statsPanel.classList.add('visible');
      
      clearTimeout(uiTimeout);
      uiTimeout = setTimeout(hideUI, 3000);
    }
    
    function hideUI() {
      if (document.fullscreenElement || !mainVideo.srcObject) return;
      document.body.classList.remove('show-ui');
      statusBar.classList.remove('visible');
      controlBar.classList.remove('visible');
      shortcutsHelp.classList.remove('visible');
      if (!showStats) statsPanel.classList.remove('visible');
    }
    
    // Event listeners for UI visibility
    document.addEventListener('mousemove', showUI);
    document.addEventListener('mousedown', showUI);
    document.addEventListener('keydown', showUI);
    
    // Status updates
    function setStatus(text, state) {
      statusText.textContent = text;
      statusDot.className = 'status-dot ' + state;
      
      if (state === 'connecting') {
        waitingTitle.textContent = text;
        waitingSubtitle.textContent = 'Please wait...';
      } else if (state === 'error') {
        waitingTitle.textContent = 'Connection Error';
        waitingSubtitle.textContent = text;
      }
    }
    
    function setWaitingState(title, subtitle) {
      waitingTitle.textContent = title;
      waitingSubtitle.textContent = subtitle;
    }
    
    // Multi-stream functions
    let updateUITimeout = null;
    let thumbnailElements = {}; // idx -> { container, video, label }
    
    function updateMultiStreamUI() {
      // Debounce rapid updates
      if (updateUITimeout) {
        clearTimeout(updateUITimeout);
      }
      updateUITimeout = setTimeout(doUpdateMultiStreamUI, 50);
    }
    
    function doUpdateMultiStreamUI() {
      const streamCount = streamOrder.length;
      
      // Update stream count display
      streamCountText.textContent = streamCount;
      streamCountEl.classList.toggle('visible', streamCount > 1);
      
      // Update layout selector visibility
      updateLayoutSelectorVisibility();
      
      // Handle based on current layout
      if (currentLayout === 'grid') {
        // In grid mode, update the grid
        updateGridLayout();
        return;
      }
      
      if (currentLayout === 'row') {
        // In row mode, update the row
        updateRowLayout();
        return;
      }
      
      // Focus mode: Show/hide thumbnails bar (show when more than 1 stream)
      const showThumbnails = streamCount > 1;
      thumbnailsBar.classList.toggle('visible', showThumbnails);
      document.body.classList.toggle('multi-stream', showThumbnails);
      
      if (!showThumbnails) {
        // Clean up all thumbnails
        thumbnailsBar.innerHTML = '';
        thumbnailElements = {};
        return;
      }
      
      // Sort streamOrder for consistent display
      const sortedOrder = [...streamOrder].sort((a, b) => a - b);
      
      // Remove thumbnails for streams that no longer exist
      for (const idx in thumbnailElements) {
        if (!streams[idx] || !sortedOrder.includes(parseInt(idx))) {
          thumbnailElements[idx].container.remove();
          delete thumbnailElements[idx];
        }
      }
      
      // Update or create thumbnails
      for (const idx of sortedOrder) {
        const data = streams[idx];
        if (!data || !data.stream) continue;
        
        let elem = thumbnailElements[idx];
        
        if (!elem) {
          // Create new thumbnail
          const container = document.createElement('div');
          container.className = 'thumbnail-container';
          container.dataset.streamIndex = idx;
          
          const video = document.createElement('video');
          video.className = 'thumbnail-video';
          video.autoplay = true;
          video.playsinline = true;
          video.muted = true;
          
          const label = document.createElement('div');
          label.className = 'thumbnail-label';
          
          const focusIndicator = document.createElement('div');
          focusIndicator.className = 'thumbnail-focus-indicator';
          
          container.appendChild(video);
          container.appendChild(label);
          container.appendChild(focusIndicator);
          
          container.addEventListener('click', () => switchToStream(idx));
          
          elem = { container, video, label };
          thumbnailElements[idx] = elem;
        }
        
        // Update video source if changed
        if (elem.video.srcObject !== data.stream) {
          elem.video.srcObject = data.stream;
          elem.video.play().catch(e => console.log('Thumbnail play error for', idx, ':', e.message));
        }
        
        // Update label
        const info = data.info;
        elem.label.textContent = info?.windowName || info?.appName || `Stream ${idx + 1}`;
        
        // Update classes
        elem.container.classList.toggle('focused', idx === sharerFocusedIndex);
        elem.container.classList.toggle('active', idx === viewerFocusedIndex);
        
        // Ensure it's in the DOM and in correct order
        if (!elem.container.parentNode) {
          thumbnailsBar.appendChild(elem.container);
        }
      }
      
      // Reorder thumbnails to match sortedOrder
      for (const idx of sortedOrder) {
        if (thumbnailElements[idx]) {
          thumbnailsBar.appendChild(thumbnailElements[idx].container);
        }
      }
    }
    
    function switchToStream(index) {
      if (!streams[index]) {
        console.log('switchToStream: stream', index, 'not found');
        return;
      }
      
      console.log('Switching to stream', index);
      
      // Swap the focused stream
      viewerFocusedIndex = index;
      selectedGridIndex = index;
      
      // Update main video (for focus mode)
      mainVideo.srcObject = streams[index].stream;
      mainVideo.play().catch(e => console.log('Main video play error:', e.message));
      
      // Reset pan/zoom when switching streams
      panZoomState.translateX = 0;
      panZoomState.translateY = 0;
      applyPanZoomTransform();
      setTimeout(updatePanZoomState, 100);
      
      // Update UI based on current layout
      updateMultiStreamUI();
    }
    
    function handleStreamsInfo(infoArray) {
      // Store the streams info array
      streamsInfo = infoArray || [];

      console.log('Received streams-info:', streamsInfo.map(i => i.trackId));

      // If we have streams-info but no streams yet, try to get them from the PeerConnection
      // This handles the case where ontrack didn't fire (e.g., renegotiation with same tracks)
      if (streamsInfo.length > 0 && Object.keys(streams).length === 0 && pc) {
        console.log('No streams stored but have streams-info, checking PeerConnection receivers');
        const receivers = pc.getReceivers();
        const transceivers = pc.getTransceivers();

        for (let i = 0; i < transceivers.length && i < 4; i++) {
          const transceiver = transceivers[i];
          const receiver = transceiver?.receiver;
          if (receiver && receiver.track && receiver.track.kind === 'video') {
            const track = receiver.track;
            const stream = new MediaStream([track]);
            const mid = transceiver.mid;
            const midNum = mid !== null ? parseInt(mid, 10) : i;
            const streamIndex = !isNaN(midNum) && midNum >= 0 && midNum <= 3 ? midNum : i;

            // Find matching streamsInfo
            const trackInfo = streamsInfo.find(info => info.trackId === `video${streamIndex}`) || null;

            if (!streams[streamIndex]) {
              streams[streamIndex] = {
                stream: stream,
                browserTrackId: track.id,
                info: trackInfo
              };
              console.log('Retrieved stream from receiver at index:', streamIndex, 'mid:', mid);

              if (trackInfo && !streamOrder.includes(streamIndex)) {
                streamOrder.push(streamIndex);
                streamOrder.sort((a, b) => a - b);
              }
            }
          }
        }
      }

      // Map info to streams by index (video0 -> index 0, video1 -> index 1, etc.)
      for (const info of streamsInfo) {
        // Extract index from trackId (e.g., "video0" -> 0)
        const match = info.trackId.match(/video(\d+)/);
        if (match) {
          const idx = parseInt(match[1], 10);

          // Update stream info if track already arrived
          if (streams[idx]) {
            streams[idx].info = info;

            // Add to streamOrder if not already there (track arrived before info)
            if (!streamOrder.includes(idx)) {
              streamOrder.push(idx);
              streamOrder.sort((a, b) => a - b);
              console.log('Added stream', idx, 'to streamOrder after receiving info');
            }
          }

          if (info.isFocused) {
            sharerFocusedIndex = idx;
          }
        }
      }
      
      // Update status when sharer has started (streams-info with actual streams)
      // The waiting overlay will be hidden when actual video arrives via ontrack
      if (streamsInfo.length > 0 && !mainVideo.srcObject) {
        setStatus('Receiving stream...', 'connecting');
      }

      // If we have active streams but no video is showing, show the first one
      if (streamOrder.length > 0 && (viewerFocusedIndex === null || !mainVideo.srcObject)) {
        const firstActiveIdx = sharerFocusedIndex !== null && streamOrder.includes(sharerFocusedIndex) 
          ? sharerFocusedIndex 
          : streamOrder[0];
        
        if (streams[firstActiveIdx]) {
          console.log('Showing first active stream:', firstActiveIdx);
          viewerFocusedIndex = firstActiveIdx;
          mainVideo.srcObject = streams[firstActiveIdx].stream;
          
          setStatus('Connected', 'connected');
          waitingEl.classList.add('hidden');
          streamStats.style.display = 'flex';
          mainVideo.play().catch(e => console.log('Autoplay blocked:', e));
          startStatsCollection();
          showUI();
        }
      }
      
      updateMultiStreamUI();
    }
    
    function handleFocusChange(focusedTrack) {
      console.log('Focus change received:', focusedTrack);
      // Extract index from trackId
      const match = focusedTrack.match(/video(\d+)/);
      if (match) {
        sharerFocusedIndex = parseInt(match[1], 10);
        console.log('Set sharerFocusedIndex to:', sharerFocusedIndex);
        
        // Only auto-follow if follow mode is enabled
        if (followMode && sharerFocusedIndex !== null && streams[sharerFocusedIndex]) {
          if (currentLayout === 'row') {
            // In ROW mode, scroll the focused window into view
            const cell = rowCells[sharerFocusedIndex]?.cell;
            if (cell) {
              cell.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
          } else {
            // In focus/grid mode, switch to the focused stream
            switchToStream(sharerFocusedIndex);
          }
        }
      }
      
      updateMultiStreamUI();
    }

    // Cursor position handling for auto-follow
    function handleCursorPosition(trackId, cursorX, cursorY, cursorInView) {
      // Only process if follow mode is enabled
      if (!followMode) return;

      const match = trackId.match(/video(\d+)/);
      if (!match) return;
      const streamIndex = parseInt(match[1], 10);

      cursorFollowState.cursorInView = cursorInView;

      if (!cursorInView) {
        // Cursor left the window - stop following
        stopCursorAnimation();
        return;
      }

      // Handle ROW layout - scroll the row container
      if (currentLayout === 'row') {
        const cell = rowCells[streamIndex];
        if (!cell || !cell.video) return;

        const video = cell.video;
        const videoWidth = video.videoWidth || parseInt(video.style.width) || 0;
        const videoHeight = video.videoHeight || parseInt(video.style.height) || 0;
        if (!videoWidth || !videoHeight) return;

        // Get row container and cell position
        const rowRect = videoRow.getBoundingClientRect();
        const cellRect = cell.cell.getBoundingClientRect();

        // Only pan if the video is larger than the viewport
        const needsHorizontalPan = videoWidth > rowRect.width;
        const needsVerticalPan = videoHeight > rowRect.height;
        if (!needsHorizontalPan && !needsVerticalPan) return;

        // Convert cursor percentage to pixel position within the video
        const cursorPixelX = (cursorX / 100) * videoWidth;
        const cursorPixelY = (cursorY / 100) * videoHeight;

        // Calculate where cursor is relative to the row container
        const cursorInRowX = (cellRect.left - rowRect.left) + videoRow.scrollLeft + cursorPixelX;
        const cursorInRowY = (cellRect.top - rowRect.top) + videoRow.scrollTop + cursorPixelY;

        // Target scroll position to center cursor in viewport (only for axes that need panning)
        const targetScrollX = needsHorizontalPan ? cursorInRowX - rowRect.width / 2 : videoRow.scrollLeft;
        const targetScrollY = needsVerticalPan ? cursorInRowY - rowRect.height / 2 : videoRow.scrollTop;

        // Smooth scroll to position
        videoRow.scrollTo({
          left: Math.max(0, targetScrollX),
          top: Math.max(0, targetScrollY),
          behavior: 'smooth'
        });
        return;
      }

      // Handle FOCUS layout with native scale - use pan/zoom
      if (currentLayout === 'focus' && currentScale === 'native' && canPan) {
        if (streamIndex !== viewerFocusedIndex) return;

        // Calculate target pan position to center cursor in viewport
        const containerRect = mainVideoContainer.getBoundingClientRect();
        const videoWidth = mainVideo.videoWidth;
        const videoHeight = mainVideo.videoHeight;

        if (!videoWidth || !videoHeight) return;

        // Convert percentage to pixel position in video
        const cursorPixelX = (cursorX / 100) * videoWidth;
        const cursorPixelY = (cursorY / 100) * videoHeight;

        // Calculate pan needed to center cursor in viewport
        // Target: cursor should be at center of viewport
        const targetX = containerRect.width / 2 - cursorPixelX;
        const targetY = containerRect.height / 2 - cursorPixelY;

        // Clamp to valid pan bounds
        const maxX = Math.max(0, videoWidth - containerRect.width);
        const maxY = Math.max(0, videoHeight - containerRect.height);

        cursorFollowState.targetX = Math.max(-maxX, Math.min(0, targetX));
        cursorFollowState.targetY = Math.max(-maxY, Math.min(0, targetY));

        // Start smooth animation if not already running
        if (!cursorFollowState.animating) {
          startCursorAnimation();
        }
      }
    }

    function startCursorAnimation() {
      if (cursorFollowState.animating) return;
      cursorFollowState.animating = true;
      animateCursorFollow();
    }

    function stopCursorAnimation() {
      cursorFollowState.animating = false;
      if (cursorFollowState.animationId) {
        cancelAnimationFrame(cursorFollowState.animationId);
        cursorFollowState.animationId = null;
      }
    }

    function animateCursorFollow() {
      if (!cursorFollowState.animating) return;

      // Lerp current position towards target
      const dx = cursorFollowState.targetX - panZoomState.translateX;
      const dy = cursorFollowState.targetY - panZoomState.translateY;

      // Check if close enough to stop
      if (Math.abs(dx) < CURSOR_SNAP_THRESHOLD && Math.abs(dy) < CURSOR_SNAP_THRESHOLD) {
        panZoomState.translateX = cursorFollowState.targetX;
        panZoomState.translateY = cursorFollowState.targetY;
        applyPanZoomTransform();
        updateMinimap();
        stopCursorAnimation();
        return;
      }

      // Apply smooth interpolation
      panZoomState.translateX += dx * CURSOR_SMOOTH_FACTOR;
      panZoomState.translateY += dy * CURSOR_SMOOTH_FACTOR;

      applyPanZoomTransform();
      updateMinimap();

      cursorFollowState.animationId = requestAnimationFrame(animateCursorFollow);
    }

    function handleSizeChange(trackId, width, height) {
      console.log('Size change received:', trackId, width, height);
      
      // Update streamsInfo with new dimensions
      const info = streamsInfo.find(i => i.trackId === trackId);
      if (info) {
        info.width = width;
        info.height = height;
      }
      
      // Also update in streams object
      const match = trackId.match(/video(\d+)/);
      if (!match) return;
      
      const streamIndex = parseInt(match[1], 10);
      if (streams[streamIndex] && streams[streamIndex].info) {
        streams[streamIndex].info.width = width;
        streams[streamIndex].info.height = height;
      }
      
      // If in grid mode with proportional sizing, recalculate layout
      if (currentLayout === 'grid' && proportionalSizing) {
        updateGridLayout();
      }
      
      // Update pan/zoom state for focus mode
      if (currentLayout === 'focus') {
        setTimeout(updatePanZoomState, 100);
      }
      
      // If this is the currently displayed stream, reset the video element
      // to force the browser to re-detect the new dimensions
      if (viewerFocusedIndex === streamIndex && mainVideo.srcObject) {
        console.log('Resetting video element for dimension change');
        const currentSrc = mainVideo.srcObject;
        mainVideo.srcObject = null;
        requestAnimationFrame(() => {
          mainVideo.srcObject = currentSrc;
          mainVideo.play().catch(e => console.log('Autoplay blocked after resize:', e));
        });
      }
    }
    
    // Handle renegotiation offer (when tracks are added/removed dynamically)
    async function handleRenegotiationOffer(sdp) {
      if (!pc) {
        console.error('No peer connection for renegotiation');
        return;
      }
      
      console.log('Processing renegotiation offer, current signaling state:', pc.signalingState);
      console.log('Current streams before renegotiation:', Object.keys(streams), 'streamOrder:', streamOrder);
      
      // Clear existing stream references - they will be repopulated via ontrack
      // This is necessary for codec changes where tracks are replaced
      const previousFocusIndex = viewerFocusedIndex;
      console.log('Clearing stream references for renegotiation, previous focus:', previousFocusIndex);
      
      // Keep streamsInfo (logical stream metadata) but clear physical track references
      for (const idx of Object.keys(streams)) {
        streams[idx] = null;
      }
      streams = {};
      streamOrder = [];
      
      // Clear video element - will be reset when new tracks arrive
      mainVideo.srcObject = null;
      
      // If we're not in stable state, we need to handle this carefully
      // This can happen if we receive an offer while we have a pending local offer
      if (pc.signalingState !== 'stable' && pc.signalingState !== 'have-remote-offer') {
        console.log('Not in stable state, waiting for state to stabilize...');
        // Wait a bit and try again
        await new Promise(resolve => setTimeout(resolve, 100));
        if (pc.signalingState !== 'stable') {
          console.error('Still not in stable state after wait:', pc.signalingState);
          // Try to rollback if possible
          try {
            await pc.setLocalDescription({ type: 'rollback' });
            console.log('Rolled back local description');
          } catch (rollbackErr) {
            console.error('Rollback failed:', rollbackErr);
          }
        }
      }
      
      try {
        // Log SDP media sections to understand what's being offered
        const mediaLines = sdp.split('\n').filter(l => l.startsWith('m=') || l.startsWith('a=mid:'));
        console.log('Renegotiation offer media sections:', mediaLines);
        
        console.log('Setting remote description for renegotiation');
        await pc.setRemoteDescription({ type: 'offer', sdp });
        console.log('Remote description set, creating answer');
        
        // Log transceivers after setting remote description
        const transceivers = pc.getTransceivers();
        console.log('Transceivers after setRemoteDescription:', transceivers.map(t => ({
          mid: t.mid,
          direction: t.direction,
          currentDirection: t.currentDirection,
          stopped: t.stopped
        })));
        
        const answer = await pc.createAnswer();
        console.log('Answer created, setting local description');
        await pc.setLocalDescription(answer);
        
        console.log('Sending renegotiation answer');
        ws.send(JSON.stringify({
          type: 'renegotiate-answer',
          peerId: currentPeerId,
          sdp: answer.sdp
        }));
        console.log('Renegotiation answer sent successfully');
        
        // Restore focus to previous index if valid (will be applied when ontrack fires)
        if (previousFocusIndex !== null) {
          console.log('Will restore focus to index', previousFocusIndex, 'when track arrives');
          // viewerFocusedIndex is kept so ontrack knows which stream to display
        }
      } catch (e) {
        console.error('Renegotiation failed:', e);
        console.error('PC state:', pc.signalingState, pc.connectionState);
      }
    }
    
    // Handle stream removed notification
    function handleStreamRemoved(trackID) {
      if (!trackID) return;
      
      // Extract index from trackId (e.g., "video2" -> 2)
      const match = trackID.match(/video(\d+)/);
      if (!match) return;
      
      const removedIndex = parseInt(match[1], 10);
      console.log('Removing stream at index:', removedIndex);
      
      // Remove from streams
      delete streams[removedIndex];
      
      // Remove from streamOrder
      streamOrder = streamOrder.filter(idx => idx !== removedIndex);
      
      // Remove from streamsInfo
      streamsInfo = streamsInfo.filter(info => info.trackId !== trackID);
      
      // If this was the viewer's focused stream, switch to another
      if (viewerFocusedIndex === removedIndex) {
        if (streamOrder.length > 0) {
          // Switch to first available stream
          switchToStream(streamOrder[0]);
        } else {
          // No streams left
          viewerFocusedIndex = null;
          mainVideo.srcObject = null;
          setStatus('Waiting for stream', 'connecting');
          waitingEl.classList.remove('hidden');
          setWaitingState('Nothing is being shared', 'Waiting for the sharer to select a window...');
          streamStats.style.display = 'none';
        }
      }
      
      // If sharer focus was on removed stream, clear it
      if (sharerFocusedIndex === removedIndex) {
        sharerFocusedIndex = null;
      }
      
      updateMultiStreamUI();
    }
    
    // Handle stream activated (fast path - no renegotiation needed)
    // The track already exists in the peer connection, just start using it
    function handleStreamActivated(info) {
      if (!info || !info.trackId) return;
      
      console.log('Stream activated (fast path):', info.trackId);
      
      // Extract index from trackId (e.g., "video1" -> 1)
      const match = info.trackId.match(/video(\d+)/);
      if (!match) return;
      
      const idx = parseInt(match[1], 10);
      
      // Update or add to streamsInfo
      const existingIdx = streamsInfo.findIndex(s => s.trackId === info.trackId);
      if (existingIdx >= 0) {
        streamsInfo[existingIdx] = info;
      } else {
        streamsInfo.push(info);
      }
      
      // If we already have the stream (track arrived via ontrack), update its info
      if (streams[idx]) {
        streams[idx].info = info;
        
        // Add to streamOrder if not already there
        if (!streamOrder.includes(idx)) {
          streamOrder.push(idx);
          streamOrder.sort((a, b) => a - b);
        }
        
        // If this is the first active stream or sharer focused, make it the main video
        if (viewerFocusedIndex === null || info.isFocused) {
          switchToStream(idx);
          
          // Show connected status if this is the first stream
          if (viewerFocusedIndex === idx) {
            setStatus('Connected', 'connected');
            waitingEl.classList.add('hidden');
            streamStats.style.display = 'flex';
            startStatsCollection();
            showUI();
          }
        }
        
        if (info.isFocused) {
          sharerFocusedIndex = idx;
        }
      }
      // If track hasn't arrived yet, it will be handled by ontrack when it arrives
      
      updateMultiStreamUI();
    }
    
    // Handle stream deactivated (fast path - no renegotiation needed)
    // The track still exists but is no longer active
    function handleStreamDeactivated(trackID) {
      if (!trackID) return;
      
      console.log('Stream deactivated (fast path):', trackID);
      
      // Extract index from trackId (e.g., "video2" -> 2)
      const match = trackID.match(/video(\d+)/);
      if (!match) return;
      
      const deactivatedIndex = parseInt(match[1], 10);
      
      // Remove info but keep the stream object (track still exists in SDP)
      if (streams[deactivatedIndex]) {
        streams[deactivatedIndex].info = null;
      }
      
      // Remove from streamOrder (not active anymore)
      streamOrder = streamOrder.filter(idx => idx !== deactivatedIndex);
      
      // Remove from streamsInfo
      streamsInfo = streamsInfo.filter(info => info.trackId !== trackID);
      
      // If this was the viewer's focused stream, switch to another
      if (viewerFocusedIndex === deactivatedIndex) {
        if (streamOrder.length > 0) {
          // Switch to first available active stream
          switchToStream(streamOrder[0]);
        } else {
          // No active streams left
          viewerFocusedIndex = null;
          mainVideo.srcObject = null;
          setStatus('Waiting for stream', 'connecting');
          waitingEl.classList.remove('hidden');
          setWaitingState('Nothing is being shared', 'Waiting for the sharer to select a window...');
          streamStats.style.display = 'none';
        }
      }
      
      // If sharer focus was on deactivated stream, clear it
      if (sharerFocusedIndex === deactivatedIndex) {
        sharerFocusedIndex = null;
      }
      
      updateMultiStreamUI();
    }
    
    // Fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(e => console.log('Fullscreen error:', e));
      } else {
        document.exitFullscreen();
      }
    }
    
    document.addEventListener('fullscreenchange', () => {
      const btn = document.getElementById('btn-fullscreen');
      if (document.fullscreenElement) {
        btn.classList.add('active');
        showUI();
      } else {
        btn.classList.remove('active');
      }
      // Update pan/zoom state for new dimensions (cursor following depends on canPan)
      if (currentScale === 'native') {
        setTimeout(updatePanZoomState, 100);
      }
    });
    
    // Picture-in-Picture
    async function togglePiP() {
      try {
        if (document.pictureInPictureElement) {
          await document.exitPictureInPicture();
        } else if (mainVideo.srcObject) {
          await mainVideo.requestPictureInPicture();
        }
      } catch (e) {
        console.log('PiP error:', e);
      }
    }
    
    mainVideo.addEventListener('enterpictureinpicture', () => {
      document.getElementById('btn-pip').classList.add('active');
    });
    
    mainVideo.addEventListener('leavepictureinpicture', () => {
      document.getElementById('btn-pip').classList.remove('active');
    });
    
    // Note: Scale mode, stats toggle, help toggle, keyboard shortcuts, 
    // and button event listeners are defined in the Layout Management section below
    
    // Password dialog functions
    function showPasswordDialog(errorText = '') {
      waitingEl.classList.add('hidden');
      passwordDialog.classList.add('visible');
      passwordInput.value = '';
      passwordInput.classList.toggle('error', !!errorText);
      passwordError.textContent = errorText;
      passwordInput.focus();
    }
    
    function hidePasswordDialog() {
      passwordDialog.classList.remove('visible');
      passwordInput.classList.remove('error');
      passwordError.textContent = '';
    }
    
    // Password form submission
    passwordForm.addEventListener('submit', (e) => {
      e.preventDefault();
      const password = passwordInput.value.trim();
      if (!password) {
        passwordInput.classList.add('error');
        passwordError.textContent = 'Please enter a password';
        return;
      }
      
      roomPassword = password;
      hidePasswordDialog();
      waitingEl.classList.remove('hidden');
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'join', role: 'viewer', password: roomPassword }));
      }
    });
    
    // WebRTC Stats collection
    function startStatsCollection() {
      if (statsInterval) clearInterval(statsInterval);
      
      statsInterval = setInterval(async () => {
        if (!pc) return;
        
        try {
          const stats = await pc.getStats();
          let videoStats = null;
          let candidatePairStats = null;
          
          stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'video') {
              videoStats = report;
            }
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              candidatePairStats = report;
            }
          });
          
          if (videoStats) {
            const res = `${videoStats.frameWidth || '--'}x${videoStats.frameHeight || '--'}`;
            document.getElementById('stat-resolution').textContent = res;
            document.getElementById('stats-resolution').textContent = res;
            
            const fps = videoStats.framesPerSecond ? Math.round(videoStats.framesPerSecond) : '--';
            document.getElementById('stat-fps').textContent = fps;
            document.getElementById('stats-framerate').textContent = fps !== '--' ? `${fps} fps` : '--';
            
            const now = Date.now();
            const bytesReceived = videoStats.bytesReceived || 0;
            if (lastStatsTime > 0 && lastBytesReceived > 0) {
              const timeDiff = (now - lastStatsTime) / 1000;
              const bytesDiff = bytesReceived - lastBytesReceived;
              const bitrate = (bytesDiff * 8) / timeDiff / 1000;
              
              let bitrateStr;
              if (bitrate >= 1000) {
                bitrateStr = (bitrate / 1000).toFixed(1) + ' Mbps';
              } else {
                bitrateStr = Math.round(bitrate) + ' kbps';
              }
              document.getElementById('stat-bitrate').textContent = bitrateStr;
              document.getElementById('stats-bitrate').textContent = bitrateStr;
            }
            lastBytesReceived = bytesReceived;
            lastStatsTime = now;
            
            const packetsLost = videoStats.packetsLost || 0;
            const packetsReceived = videoStats.packetsReceived || 0;
            const lossPercent = packetsReceived > 0 ? ((packetsLost / (packetsLost + packetsReceived)) * 100).toFixed(1) : 0;
            const lossEl = document.getElementById('stats-packets-lost');
            lossEl.textContent = `${packetsLost} (${lossPercent}%)`;
            lossEl.className = 'stats-value ' + (lossPercent > 5 ? 'bad' : lossPercent > 1 ? 'warn' : 'good');
            
            const jitter = videoStats.jitter ? (videoStats.jitter * 1000).toFixed(1) + ' ms' : '--';
            document.getElementById('stats-jitter').textContent = jitter;
          }
          
          if (candidatePairStats) {
            const rtt = candidatePairStats.currentRoundTripTime;
            const latencyEl = document.getElementById('stats-latency');
            if (rtt !== undefined) {
              const latencyMs = Math.round(rtt * 1000);
              latencyEl.textContent = latencyMs + ' ms';
              latencyEl.className = 'stats-value ' + (latencyMs > 200 ? 'bad' : latencyMs > 100 ? 'warn' : 'good');
            } else {
              latencyEl.textContent = '--';
            }
            
            const connTypeEl = document.getElementById('stats-connection-type');
            const localCandidateId = candidatePairStats.localCandidateId;
            let connectionType = 'Unknown';
            
            stats.forEach(report => {
              if (report.type === 'local-candidate' && report.id === localCandidateId) {
                switch (report.candidateType) {
                  case 'relay':
                    connectionType = 'Relay (TURN)';
                    connTypeEl.className = 'stats-value warn';
                    break;
                  case 'host':
                    connectionType = 'Direct (P2P)';
                    connTypeEl.className = 'stats-value good';
                    break;
                  case 'srflx':
                  case 'prflx':
                    connectionType = 'NAT (P2P)';
                    connTypeEl.className = 'stats-value good';
                    break;
                }
              }
            });
            connTypeEl.textContent = connectionType;
          }
        } catch (e) {
          console.log('Stats error:', e);
        }
      }, 1000);
    }
    
    function stopStatsCollection() {
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }
    }
    
    // WebRTC Connection
    async function connect() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${protocol}//${window.location.host}/ws/${roomCode}`;
      
      console.log('Connecting to WebSocket:', wsUrl);
      setStatus('Connecting...', 'connecting');
      setWaitingState('Connecting...', 'Establishing connection to server');
      
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('WebSocket connected!');
        setStatus('Joining room...', 'connecting');
        setWaitingState('Joining Room', 'Waiting for sharer...');
        reconnectAttempts = 0;
        const joinMsg = { type: 'join', role: 'viewer' };
        if (roomPassword) {
          joinMsg.password = roomPassword;
        }
        ws.send(JSON.stringify(joinMsg));
      };
      
      ws.onmessage = async (event) => {
        const msg = JSON.parse(event.data);
        console.log('WebSocket message received:', msg.type, msg);
        
        switch (msg.type) {
          case 'joined':
            setStatus('Waiting for sharer...', 'connecting');
            setWaitingState('Waiting for Sharer', 'The stream will begin when the sharer starts');
            break;
            
          case 'offer':
            currentPeerId = msg.peerId;
            // Check if this is a renegotiation (pc exists and is connected)
            if (pc && pc.signalingState !== 'closed') {
              console.log('Handling renegotiation offer');
              await handleRenegotiationOffer(msg.sdp);
            } else {
              await handleOffer(msg.sdp);
            }
            break;
            
          case 'ice':
            await handleICE(msg.candidate);
            break;
            
          case 'streams-info':
            handleStreamsInfo(msg.streams || []);
            break;
            
          case 'focus-change':
            handleFocusChange(msg.focusedTrack);
            break;
            
          case 'size-change':
            handleSizeChange(msg.trackId, msg.width, msg.height);
            break;

          case 'cursor-position':
            handleCursorPosition(msg.trackId, msg.cursorX, msg.cursorY, msg.cursorInView);
            break;

          case 'stream-added':
            console.log('Stream added:', msg.streamAdded);
            if (msg.streamAdded) {
              // Add to streamsInfo - track will be associated when it arrives via ontrack
              streamsInfo.push(msg.streamAdded);
            }
            break;
            
          case 'stream-removed':
            console.log('Stream removed:', msg.streamRemoved);
            handleStreamRemoved(msg.streamRemoved);
            break;
          
          case 'stream-activated':
            // Fast path: stream activated on pre-allocated slot (no renegotiation!)
            console.log('Stream activated (fast path):', msg.streamActivated);
            if (msg.streamActivated) {
              handleStreamActivated(msg.streamActivated);
            }
            break;
            
          case 'stream-deactivated':
            // Fast path: stream deactivated (no renegotiation!)
            console.log('Stream deactivated (fast path):', msg.streamDeactivated);
            if (msg.streamDeactivated) {
              handleStreamDeactivated(msg.streamDeactivated);
            }
            break;
            
          case 'sharer-ready':
            console.log('Sharer ready - waiting for offer');
            setStatus('Connecting...', 'connecting');
            if (pc) {
              pc.close();
              pc = null;
              stopStatsCollection();
            }
            streams = {};
            streamOrder = [];
            streamsInfo = [];
            viewerFocusedIndex = null;
            sharerFocusedIndex = null;
            mainVideo.srcObject = null;
            streamStats.style.display = 'none';
            updateMultiStreamUI();
            // Hide waiting overlay - offer should arrive shortly
            // Server already sent viewer-joined to sharer when sharer connected
            waitingEl.classList.add('hidden');
            break;
            
          case 'sharer-stopped':
            console.log('Sharer stopped sharing');
            setStatus('Waiting for stream', 'connecting');
            if (pc) {
              pc.close();
              pc = null;
              stopStatsCollection();
            }
            streams = {};
            streamOrder = [];
            streamsInfo = [];
            viewerFocusedIndex = null;
            sharerFocusedIndex = null;
            mainVideo.srcObject = null;
            streamStats.style.display = 'none';
            updateMultiStreamUI();
            setWaitingState('Sharer Stopped', 'Waiting for sharer to start streaming again...');
            waitingEl.classList.remove('hidden');
            // Don't rejoin yet - wait for sharer-ready message
            break;
          
          case 'sharer-started':
            console.log('Sharer started sharing - closing old connection and rejoining');
            setStatus('Connecting...', 'connecting');
            setWaitingState('Connecting', 'Sharer started streaming, establishing connection...');
            // Close old connection to ensure clean reconnection
            if (pc) {
              pc.close();
              pc = null;
              stopStatsCollection();
            }
            streams = {};
            streamOrder = [];
            streamsInfo = [];
            viewerFocusedIndex = null;
            sharerFocusedIndex = null;
            mainVideo.srcObject = null;
            streamStats.style.display = 'none';
            updateMultiStreamUI();
            // Now rejoin to get a new offer
            const rejoinMsg = { type: 'join', role: 'viewer' };
            if (roomPassword) {
              rejoinMsg.password = roomPassword;
            }
            ws.send(JSON.stringify(rejoinMsg));
            break;
            
          case 'password-required':
            showPasswordDialog();
            break;
            
          case 'password-invalid':
            showPasswordDialog('Invalid password. Please try again.');
            break;
            
          case 'error':
            setStatus(msg.error, 'error');
            if (msg.error === 'Sharer disconnected') {
              if (pc) {
                pc.close();
                pc = null;
                stopStatsCollection();
              }
              streams = {};
              streamOrder = [];
              streamsInfo = [];
              viewerFocusedIndex = null;
              sharerFocusedIndex = null;
              mainVideo.srcObject = null;
              streamStats.style.display = 'none';
              updateMultiStreamUI();
              setWaitingState('Sharer Reconnecting', 'Please wait...');
              waitingEl.classList.remove('hidden');
            }
            break;
        }
      };
      
      ws.onclose = () => {
        setStatus('Disconnected', 'error');
        stopStatsCollection();
        attemptReconnect();
      };
      
      ws.onerror = () => {
        setStatus('Connection error', 'error');
      };
    }
    
    function attemptReconnect() {
      if (reconnectAttempts < maxReconnectAttempts) {
        reconnectAttempts++;
        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts - 1), 10000);
        setStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');
        setWaitingState('Reconnecting...', `Attempt ${reconnectAttempts} of ${maxReconnectAttempts}`);
        setTimeout(connect, delay);
      } else {
        setStatus('Failed to connect', 'error');
        setWaitingState('Connection Failed', 'Please refresh the page to try again');
      }
    }
    
    async function handleOffer(sdp) {
      setStatus('Establishing connection...', 'connecting');
      
      if (pc) {
        pc.close();
        pc = null;
        stopStatsCollection();
      }
      
      // Reset stream state
      streams = {};
      streamOrder = [];
      streamsInfo = [];
      viewerFocusedIndex = null;
      sharerFocusedIndex = null;
      
      pc = new RTCPeerConnection({ iceServers });
      
      pc.ontrack = (event) => {
        const track = event.track;
        let stream = event.streams[0];
        
        // If no stream provided, create one from the track
        if (!stream) {
          console.log('No stream in event, creating new MediaStream for track');
          stream = new MediaStream([track]);
        }
        
        // Get the transceiver's mid to determine the track index
        // The mid corresponds to the m-line order in SDP (video0, video1, etc.)
        const transceiver = event.transceiver;
        const mid = transceiver?.mid;
        
        console.log('Received track:', track.id, track.kind, 'mid:', mid, 'stream:', stream?.id, 'muted:', track.muted, 'readyState:', track.readyState);
        console.log('Stream tracks:', stream.getTracks().map(t => t.id + '/' + t.kind + '/' + t.readyState));
        console.log('Current streamOrder:', streamOrder, 'streamsInfo:', streamsInfo.map(i => i.trackId));
        
        // Listen for track unmute (tracks may arrive muted initially)
        track.onunmute = () => {
          console.log('Track unmuted:', track.id, 'mid:', mid);
          updateMultiStreamUI();
        };
        
        track.onended = () => {
          console.log('Track ended:', track.id);
        };
        
        if (track.kind === 'video') {
          // Determine stream index for this track
          // After renegotiation (codec change), mids may not match logical indices
          let streamIndex = null;
          
          console.log('ontrack: Processing video track, mid:', mid, 'stream.id:', stream.id, 'track.id:', track.id);
          
          // Method 1: Check if we already have this exact stream (by stream ID)
          for (const idx of Object.keys(streams)) {
            if (streams[idx]?.stream?.id === stream.id) {
              console.log('Stream already exists at index', idx, ', updating track reference');
              streams[idx].browserTrackId = track.id;
              streams[idx].stream = stream;
              updateMultiStreamUI();
              return;
            }
          }
          
          // Method 2: Use transceiver mid if it maps to a valid streamsInfo entry (0-3)
          // This works for initial connection where mids are 0,1,2,3
          if (mid !== null && mid !== undefined) {
            const midNum = parseInt(mid, 10);
            if (!isNaN(midNum) && midNum >= 0 && midNum <= 3) {
              // Check if we have streamsInfo for this index and haven't already stored a stream here
              const hasInfo = streamsInfo.some(i => i.trackId === `video${midNum}`);
              if (hasInfo && !streams[midNum]) {
                streamIndex = midNum;
                console.log('Using transceiver mid for index:', streamIndex);
              }
            }
          }
          
          // Method 3: Assign to next available slot that has streamsInfo
          // This handles renegotiation where mids don't match logical indices
          if (streamIndex === null) {
            const sortedInfo = [...streamsInfo].sort((a, b) => {
              const aMatch = a.trackId.match(/video(\d+)/);
              const bMatch = b.trackId.match(/video(\d+)/);
              return (aMatch ? parseInt(aMatch[1], 10) : 999) - (bMatch ? parseInt(bMatch[1], 10) : 999);
            });
            
            for (const info of sortedInfo) {
              const match = info.trackId.match(/video(\d+)/);
              if (match) {
                const infoIndex = parseInt(match[1], 10);
                if (!streams[infoIndex]) {
                  streamIndex = infoIndex;
                  console.log('Matched track to next available streamsInfo index:', streamIndex, 'trackId:', info.trackId);
                  break;
                }
              }
            }
          }
          
          // Method 4: Calculate next index based on existing streams (fallback)
          if (streamIndex === null) {
            const existingIndices = Object.keys(streams).map(k => parseInt(k, 10)).filter(n => !isNaN(n));
            streamIndex = existingIndices.length > 0 ? Math.max(...existingIndices) + 1 : 0;
            console.log('Using calculated next index:', streamIndex);
          }
          
          // Find the matching streamsInfo for this track
          const trackInfo = streamsInfo.find(i => i.trackId === `video${streamIndex}`) || null;
          
          // Store the stream (even if inactive, we need to keep the reference)
          streams[streamIndex] = {
            stream: stream,
            browserTrackId: track.id,
            info: trackInfo
          };
          
          // Only add to streamOrder if this track is active (has info)
          // Inactive pre-allocated tracks should not be displayed
          if (trackInfo) {
            if (!streamOrder.includes(streamIndex)) {
              streamOrder.push(streamIndex);
              streamOrder.sort((a, b) => a - b); // Keep sorted
            }
            
            console.log('Added active stream at index:', streamIndex, 'total active:', streamOrder.length, 'track muted:', track.muted);
            
            // Determine if we should display this stream
            const shouldDisplay = 
              viewerFocusedIndex === null ||  // No focus set yet (first stream)
              viewerFocusedIndex === streamIndex;  // This is the focused stream (renegotiation)
            
            if (shouldDisplay) {
              const isFirstStream = viewerFocusedIndex === null;
              viewerFocusedIndex = streamIndex;
              mainVideo.srcObject = stream;
              
              if (isFirstStream) {
                // First stream - initialize everything
                setStatus('Connected', 'connected');
                waitingEl.classList.add('hidden');
                streamStats.style.display = 'flex';
                startStatsCollection();
                showUI();
              } else {
                // Renegotiation - just update the stream
                console.log('Updating focused stream to new track (renegotiation)');
              }
              mainVideo.play().catch(e => console.log('Autoplay blocked:', e));
            }
          } else {
            console.log('Stored inactive pre-allocated track at index:', streamIndex, '(not displaying until activated)');
          }
          
          updateMultiStreamUI();
        }
      };
      
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          ws.send(JSON.stringify({
            type: 'ice',
            peerId: currentPeerId,
            candidate: JSON.stringify(event.candidate)
          }));
        }
      };
      
      pc.oniceconnectionstatechange = () => {
        console.log('ICE connection state:', pc.iceConnectionState);
        switch (pc.iceConnectionState) {
          case 'connected':
            setStatus('Connected', 'connected');
            break;
          case 'disconnected':
            setStatus('Reconnecting...', 'connecting');
            break;
          case 'failed':
          case 'closed':
            setStatus('Connection lost', 'connecting');
            stopStatsCollection();
            pc.close();
            pc = null;
            // Request to rejoin - server will send new offer
            if (ws && ws.readyState === WebSocket.OPEN) {
              console.log('Peer connection closed, requesting rejoin...');
              setWaitingState('Reconnecting...', 'Waiting for sharer to start streaming');
              waitingEl.classList.remove('hidden');
              const joinMsg = { type: 'join', role: 'viewer' };
              if (roomPassword) {
                joinMsg.password = roomPassword;
              }
              ws.send(JSON.stringify(joinMsg));
            }
            break;
        }
      };
      
      try {
        await pc.setRemoteDescription({ type: 'offer', sdp });
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        ws.send(JSON.stringify({
          type: 'answer',
          peerId: currentPeerId,
          sdp: answer.sdp
        }));
      } catch (err) {
        console.error('Error handling offer:', err);
        setStatus('Connection error', 'error');
      }
    }
    
    async function handleICE(candidateStr) {
      if (!pc) return;
      try {
        const candidate = JSON.parse(candidateStr);
        await pc.addIceCandidate(candidate);
      } catch (err) {
        console.error('ICE error:', err);
      }
    }
    
    // ==========================================
    // Layout Management
    // ==========================================
    
    function setLayout(layout) {
      if (layout === currentLayout) return;
      
      currentLayout = layout;
      console.log('Switching to layout:', layout);
      
      // Update button states
      document.querySelectorAll('.layout-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.layout === layout);
      });
      
      // Show/hide proportional toggle (only in grid mode)
      proportionalToggle.classList.toggle('visible', layout === 'grid' && streamOrder.length > 1);
      layoutDivider.style.display = (layout === 'grid' && streamOrder.length > 1) ? '' : 'none';
      
      // Hide all layout containers first
      mainVideoContainer.style.display = 'none';
      videoGrid.classList.remove('visible');
      videoRow.classList.remove('visible');
      rowMinimap.classList.remove('visible');
      thumbnailsBar.classList.remove('visible');
      document.body.classList.remove('multi-stream');
      
      if (layout === 'focus') {
        // Switch to focus mode
        mainVideoContainer.style.display = '';
        thumbnailsBar.classList.toggle('visible', streamOrder.length > 1);
        document.body.classList.toggle('multi-stream', streamOrder.length > 1);
        
        // Ensure main video has the focused stream
        if (viewerFocusedIndex !== null && streams[viewerFocusedIndex]) {
          mainVideo.srcObject = streams[viewerFocusedIndex].stream;
          mainVideo.play().catch(e => console.log('Play error:', e));
        }
        
        // Clean up grid and row cells
        videoGrid.innerHTML = '';
        gridCells = {};
        cleanupRowCells();
        
      } else if (layout === 'grid') {
        // Switch to grid mode
        videoGrid.classList.add('visible');
        
        // Clean up row cells
        cleanupRowCells();
        
        // Build the grid
        updateGridLayout();
        
      } else if (layout === 'row') {
        // Switch to row mode
        videoRow.classList.add('visible');
        
        // Clean up grid cells
        videoGrid.innerHTML = '';
        gridCells = {};
        
        // Build the row
        updateRowLayout();
      }
    }

    function toggleLayout() {
      // Cycle through: focus -> grid -> row -> focus
      const layouts = ['focus', 'grid', 'row'];
      const currentIdx = layouts.indexOf(currentLayout);
      const nextIdx = (currentIdx + 1) % layouts.length;
      setLayout(layouts[nextIdx]);
    }
    
    function cleanupRowCells() {
      videoRow.innerHTML = '';
      rowMinimap.innerHTML = '';
      rowMinimap.classList.remove('visible');
      rowCells = {};
    }
    
    function toggleProportionalSizing() {
      proportionalSizing = !proportionalSizing;
      proportionalSwitch.classList.toggle('active', proportionalSizing);

      if (currentLayout === 'grid') {
        updateGridLayout();
      }
    }
    
    function toggleFollowMode() {
      followMode = !followMode;
      followSwitch.classList.toggle('active', followMode);
      console.log('Follow mode:', followMode ? 'ON' : 'OFF');

      // Stop cursor animation if follow mode disabled
      if (!followMode) {
        stopCursorAnimation();
      }
    }
    
    function calculateProportionalSizes() {
      const activeStreams = streamOrder.map(idx => {
        const s = streams[idx];
        const info = s?.info;
        return {
          index: idx,
          width: info?.width || 1920,
          height: info?.height || 1080,
          area: (info?.width || 1920) * (info?.height || 1080)
        };
      });
      
      if (activeStreams.length === 0) return { cols: [], rows: [] };
      
      const totalArea = activeStreams.reduce((sum, s) => sum + s.area, 0);
      
      // Calculate relative weights with minimum of 25%
      const weights = activeStreams.map(s => Math.max(0.25, s.area / totalArea));
      const weightSum = weights.reduce((a, b) => a + b, 0);
      const normalizedWeights = weights.map(w => w / weightSum);
      
      return {
        streams: activeStreams,
        weights: normalizedWeights
      };
    }
    
    function updateGridLayout() {
      const count = streamOrder.length;
      
      if (count === 0) {
        videoGrid.innerHTML = '';
        videoGrid.className = 'visible';
        gridCells = {};
        return;
      }
      
      // Remove old grid classes
      videoGrid.className = 'visible';
      videoGrid.classList.add(`grid-${Math.min(count, 4)}`);
      videoGrid.classList.toggle('equal-size', !proportionalSizing);
      
      // Calculate proportional sizes
      if (proportionalSizing && count >= 2) {
        const sizes = calculateProportionalSizes();
        
        if (count === 2) {
          // Side by side: proportional columns
          const w1 = sizes.weights[0] || 0.5;
          const w2 = sizes.weights[1] || 0.5;
          videoGrid.style.setProperty('--col-1', `${w1}fr`);
          videoGrid.style.setProperty('--col-2', `${w2}fr`);
        } else if (count === 3) {
          // 1 large on left, 2 stacked on right
          const w1 = Math.max(sizes.weights[0], 0.4);
          const remaining = 1 - w1;
          videoGrid.style.setProperty('--col-1', `${w1}fr`);
          videoGrid.style.setProperty('--col-2', `${remaining}fr`);
          
          // Row heights for right side
          const h1 = sizes.weights[1] / (sizes.weights[1] + sizes.weights[2]);
          videoGrid.style.setProperty('--row-1', `${h1}fr`);
          videoGrid.style.setProperty('--row-2', `${1 - h1}fr`);
        } else if (count === 4) {
          // 2x2 grid with proportional sizing
          const topWeight = (sizes.weights[0] + sizes.weights[1]) / 2;
          const bottomWeight = (sizes.weights[2] + sizes.weights[3]) / 2;
          const leftWeight = (sizes.weights[0] + sizes.weights[2]) / 2;
          const rightWeight = (sizes.weights[1] + sizes.weights[3]) / 2;
          
          videoGrid.style.setProperty('--col-1', `${leftWeight / (leftWeight + rightWeight)}fr`);
          videoGrid.style.setProperty('--col-2', `${rightWeight / (leftWeight + rightWeight)}fr`);
          videoGrid.style.setProperty('--row-1', `${topWeight / (topWeight + bottomWeight)}fr`);
          videoGrid.style.setProperty('--row-2', `${bottomWeight / (topWeight + bottomWeight)}fr`);
        }
      } else {
        // Reset to equal sizing
        videoGrid.style.removeProperty('--col-1');
        videoGrid.style.removeProperty('--col-2');
        videoGrid.style.removeProperty('--row-1');
        videoGrid.style.removeProperty('--row-2');
      }
      
      // Create or update grid cells
      const sortedOrder = [...streamOrder].sort((a, b) => a - b);
      
      // Remove cells for streams that no longer exist
      for (const idx in gridCells) {
        if (!sortedOrder.includes(parseInt(idx))) {
          gridCells[idx].cell.remove();
          delete gridCells[idx];
        }
      }
      
      // Create or update cells
      for (const idx of sortedOrder) {
        const data = streams[idx];
        if (!data || !data.stream) continue;
        
        let cell = gridCells[idx];
        
        if (!cell) {
          // Create new cell
          const cellEl = document.createElement('div');
          cellEl.className = 'grid-cell';
          cellEl.dataset.streamIndex = idx;
          
          const video = document.createElement('video');
          video.autoplay = true;
          video.playsinline = true;
          video.muted = true;
          
          const label = document.createElement('div');
          label.className = 'grid-cell-label';
          
          cellEl.appendChild(video);
          cellEl.appendChild(label);
          
          // Click handlers
          let clickTimeout = null;
          cellEl.addEventListener('click', (e) => {
            if (clickTimeout) {
              // Double click - switch to focus mode with this stream
              clearTimeout(clickTimeout);
              clickTimeout = null;
              viewerFocusedIndex = idx;
              setLayout('focus');
            } else {
              // Single click - just select
              clickTimeout = setTimeout(() => {
                clickTimeout = null;
                selectGridCell(idx);
              }, 250);
            }
          });
          
          cell = { cell: cellEl, video, label };
          gridCells[idx] = cell;
        }
        
        // Update video source
        if (cell.video.srcObject !== data.stream) {
          cell.video.srcObject = data.stream;
          cell.video.play().catch(e => console.log('Grid video play error:', e));
        }
        
        // Update label
        const info = data.info;
        cell.label.textContent = info?.windowName || info?.appName || `Stream ${idx + 1}`;
        
        // Update classes
        cell.cell.classList.toggle('selected', idx === selectedGridIndex);
        cell.cell.classList.toggle('sharer-focused', idx === sharerFocusedIndex);
        
        // Ensure it's in the DOM
        if (!cell.cell.parentNode) {
          videoGrid.appendChild(cell.cell);
        }
      }
      
      // Reorder cells
      for (const idx of sortedOrder) {
        if (gridCells[idx]) {
          videoGrid.appendChild(gridCells[idx].cell);
        }
      }
    }
    
    function selectGridCell(index) {
      selectedGridIndex = index;
      
      // Update cell classes in grid
      for (const idx in gridCells) {
        gridCells[idx].cell.classList.toggle('selected', parseInt(idx) === index);
      }
      
      // Update cell classes in row
      for (const idx in rowCells) {
        rowCells[idx].cell.classList.toggle('selected', parseInt(idx) === index);
      }
    }
    
    // Update layout selector visibility based on stream count
    function updateLayoutSelectorVisibility() {
      const showSelector = streamOrder.length > 1;
      layoutSelector.classList.toggle('visible', showSelector);
      layoutDivider.style.display = (showSelector && currentLayout === 'grid') ? '' : 'none';
      proportionalToggle.classList.toggle('visible', showSelector && currentLayout === 'grid');

      // Show follow toggle when there are multiple streams OR when cursor following is possible
      // (native scale + can pan in focus mode, or in row mode)
      const showFollow = showSelector || (currentScale === 'native' && canPan) || currentLayout === 'row';
      followToggle.classList.toggle('visible', showFollow);
      
      // If we only have 1 stream, force focus layout
      if (streamOrder.length <= 1 && (currentLayout === 'grid' || currentLayout === 'row')) {
        setLayout('focus');
      }
    }
    
    // ==========================================
    // Row Layout
    // ==========================================
    
    function updateRowLayout() {
      const count = streamOrder.length;
      
      if (count === 0) {
        cleanupRowCells();
        return;
      }
      
      const sortedOrder = [...streamOrder].sort((a, b) => a - b);
      
      // Remove cells for streams that no longer exist
      for (const idx in rowCells) {
        if (!sortedOrder.includes(parseInt(idx))) {
          rowCells[idx].cell.remove();
          if (rowCells[idx].minimapItem) {
            rowCells[idx].minimapItem.remove();
          }
          delete rowCells[idx];
        }
      }
      
      // Create or update cells
      for (const idx of sortedOrder) {
        const data = streams[idx];
        if (!data || !data.stream) continue;
        
        let cell = rowCells[idx];
        
        if (!cell) {
          // Create new row cell
          const cellEl = document.createElement('div');
          cellEl.className = 'row-cell';
          cellEl.dataset.streamIndex = idx;
          
          const video = document.createElement('video');
          video.autoplay = true;
          video.playsinline = true;
          video.muted = true;
          
          const label = document.createElement('div');
          label.className = 'row-cell-label';
          
          cellEl.appendChild(video);
          cellEl.appendChild(label);
          
          // Double click to focus
          cellEl.addEventListener('dblclick', (e) => {
            e.preventDefault();
            viewerFocusedIndex = idx;
            setLayout('focus');
          });
          
          // Create minimap item
          const minimapItem = document.createElement('div');
          minimapItem.className = 'row-minimap-item';
          minimapItem.dataset.streamIndex = idx;
          const minimapCanvas = document.createElement('canvas');
          minimapItem.appendChild(minimapCanvas);
          
          // Click on minimap item to scroll to that stream
          minimapItem.addEventListener('click', () => {
            const cellElement = rowCells[idx]?.cell;
            if (cellElement) {
              cellElement.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
            }
          });
          
          cell = { cell: cellEl, video, label, minimapItem, minimapCanvas };
          rowCells[idx] = cell;
        }
        
        // Update video source
        if (cell.video.srcObject !== data.stream) {
          cell.video.srcObject = data.stream;
          cell.video.play().catch(e => console.log('Row video play error:', e));
        }
        
        // TRUE NATIVE SIZE - no scaling whatsoever for 100% sharpness
        const info = data.info;
        if (info?.width && info?.height) {
          cell.video.style.width = info.width + 'px';
          cell.video.style.height = info.height + 'px';
        } else {
          // Use video's native dimensions if no info
          cell.video.style.width = 'auto';
          cell.video.style.height = 'auto';
        }
        
        // Update label
        cell.label.textContent = info?.windowName || info?.appName || `Stream ${idx + 1}`;
        
        // Update classes
        cell.cell.classList.toggle('selected', idx === selectedGridIndex);
        cell.cell.classList.toggle('sharer-focused', idx === sharerFocusedIndex);
        cell.minimapItem.classList.toggle('sharer-focused', idx === sharerFocusedIndex);
        
        // Ensure cell is in the DOM
        if (!cell.cell.parentNode) {
          videoRow.appendChild(cell.cell);
        }
        
        // Ensure minimap item is in the DOM
        if (!cell.minimapItem.parentNode) {
          rowMinimap.appendChild(cell.minimapItem);
        }
      }
      
      // Reorder cells
      for (const idx of sortedOrder) {
        if (rowCells[idx]) {
          videoRow.appendChild(rowCells[idx].cell);
          rowMinimap.appendChild(rowCells[idx].minimapItem);
        }
      }
      
      // Show minimap if we have content
      rowMinimap.classList.toggle('visible', count > 0);
      
      // Update minimap thumbnails
      updateRowMinimap();
    }
    
    // Row minimap update
    let rowMinimapInterval = null;
    
    function updateRowMinimap() {
      const sortedOrder = [...streamOrder].sort((a, b) => a - b);
      
      for (const idx of sortedOrder) {
        const cell = rowCells[idx];
        if (!cell || !cell.video || !cell.minimapCanvas) continue;
        
        const video = cell.video;
        const canvas = cell.minimapCanvas;
        
        // Only draw if video has dimensions
        if (video.videoWidth && video.videoHeight) {
          const aspectRatio = video.videoWidth / video.videoHeight;
          const height = 36;
          const width = height * aspectRatio;
          
          canvas.width = width;
          canvas.height = height;
          canvas.style.width = width + 'px';
          canvas.style.height = height + 'px';
          
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0, width, height);
        }
        
        // Update in-view state
        const cellRect = cell.cell.getBoundingClientRect();
        const containerRect = videoRow.getBoundingClientRect();
        const isInView = cellRect.left < containerRect.right && cellRect.right > containerRect.left;
        cell.minimapItem.classList.toggle('in-view', isInView);
      }
    }
    
    function startRowMinimapUpdates() {
      if (rowMinimapInterval) return;
      rowMinimapInterval = setInterval(() => {
        if (currentLayout === 'row' && rowMinimap.classList.contains('visible')) {
          updateRowMinimap();
        }
      }, 200);
    }
    
    function stopRowMinimapUpdates() {
      if (rowMinimapInterval) {
        clearInterval(rowMinimapInterval);
        rowMinimapInterval = null;
      }
    }
    
    // Row drag-to-scroll
    let rowDragState = {
      isDragging: false,
      startX: 0,
      startY: 0,
      scrollLeft: 0,
      scrollTop: 0
    };
    
    videoRow.addEventListener('mousedown', (e) => {
      // Don't start drag if clicking on a video cell's interactive area
      if (e.target.closest('.row-cell-label')) return;
      
      rowDragState.isDragging = true;
      rowDragState.startX = e.pageX - videoRow.offsetLeft;
      rowDragState.startY = e.pageY - videoRow.offsetTop;
      rowDragState.scrollLeft = videoRow.scrollLeft;
      rowDragState.scrollTop = videoRow.scrollTop;
      videoRow.classList.add('dragging');
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!rowDragState.isDragging) return;
      e.preventDefault();
      
      const x = e.pageX - videoRow.offsetLeft;
      const y = e.pageY - videoRow.offsetTop;
      const walkX = (x - rowDragState.startX) * 1.5;
      const walkY = (y - rowDragState.startY) * 1.5;
      
      videoRow.scrollLeft = rowDragState.scrollLeft - walkX;
      videoRow.scrollTop = rowDragState.scrollTop - walkY;
    });
    
    document.addEventListener('mouseup', () => {
      rowDragState.isDragging = false;
      videoRow.classList.remove('dragging');
    });
    
    // Touch support for row drag
    videoRow.addEventListener('touchstart', (e) => {
      if (e.touches.length !== 1) return;
      const touch = e.touches[0];
      
      rowDragState.isDragging = true;
      rowDragState.startX = touch.pageX - videoRow.offsetLeft;
      rowDragState.startY = touch.pageY - videoRow.offsetTop;
      rowDragState.scrollLeft = videoRow.scrollLeft;
      rowDragState.scrollTop = videoRow.scrollTop;
    }, { passive: true });
    
    videoRow.addEventListener('touchmove', (e) => {
      if (!rowDragState.isDragging || e.touches.length !== 1) return;
      const touch = e.touches[0];
      
      const x = touch.pageX - videoRow.offsetLeft;
      const y = touch.pageY - videoRow.offsetTop;
      const walkX = x - rowDragState.startX;
      const walkY = y - rowDragState.startY;
      
      videoRow.scrollLeft = rowDragState.scrollLeft - walkX;
      videoRow.scrollTop = rowDragState.scrollTop - walkY;
    }, { passive: true });
    
    videoRow.addEventListener('touchend', () => {
      rowDragState.isDragging = false;
    });
    
    // Update layout on resize
    window.addEventListener('resize', () => {
      if (currentLayout === 'row') {
        updateRowLayout();
      }
      // Update native mode centering on resize
      if (currentScale === 'native') {
        updatePanZoomState();
      }
    });
    
    // Start row minimap updates
    startRowMinimapUpdates();
    
    // ==========================================
    // Pan/Zoom for Native View
    // ==========================================
    
    function updatePanZoomState() {
      const video = mainVideo;
      if (!video.videoWidth || !video.videoHeight) {
        canPan = false;
        panZoomContainer.classList.remove('can-pan');
        minimap.classList.remove('visible');
        return;
      }
      
      const containerRect = mainVideoContainer.getBoundingClientRect();
      // Use intrinsic video dimensions (what native mode renders at)
      const videoWidth = video.videoWidth;
      const videoHeight = video.videoHeight;

      // Check if content exceeds viewport in native mode
      canPan = currentScale === 'native' &&
               (videoWidth > containerRect.width || videoHeight > containerRect.height);

      panZoomContainer.classList.toggle('can-pan', canPan);

      if (canPan) {
        // Calculate bounds - 0 is top-left, negative values pan to see more content
        const maxX = Math.max(0, videoWidth - containerRect.width);
        const maxY = Math.max(0, videoHeight - containerRect.height);

        // Clamp to bounds (0 = top-left, -maxX/Y = bottom-right)
        panZoomState.translateX = Math.max(-maxX, Math.min(0, panZoomState.translateX));
        panZoomState.translateY = Math.max(-maxY, Math.min(0, panZoomState.translateY));

        applyPanZoomTransform();
        updateMinimap();
        minimap.classList.add('visible');
      } else {
        // Reset transform
        panZoomState.translateX = 0;
        panZoomState.translateY = 0;
        applyPanZoomTransform();
        minimap.classList.remove('visible');
      }

      // Update follow toggle visibility (depends on canPan for cursor following)
      updateLayoutSelectorVisibility();
    }

    function applyPanZoomTransform() {
      if (currentScale === 'native' && mainVideo.videoWidth && mainVideo.videoHeight) {
        const containerRect = mainVideoContainer.getBoundingClientRect();
        const videoWidth = mainVideo.videoWidth;
        const videoHeight = mainVideo.videoHeight;

        // Only center if video is SMALLER than viewport
        // For large videos, start at (0,0) and allow panning
        const fitsX = videoWidth <= containerRect.width;
        const fitsY = videoHeight <= containerRect.height;

        const centerX = fitsX ? (containerRect.width - videoWidth) / 2 : 0;
        const centerY = fitsY ? (containerRect.height - videoHeight) / 2 : 0;

        // Apply centering (for small) + pan offset (for large)
        const x = centerX + panZoomState.translateX;
        const y = centerY + panZoomState.translateY;
        panZoomContent.style.transform = `translate(${x}px, ${y}px)`;
      } else {
        panZoomContent.style.transform = '';
      }
    }
    
    function updateMinimap() {
      if (!canPan || !mainVideo.videoWidth) return;

      const video = mainVideo;
      const containerRect = mainVideoContainer.getBoundingClientRect();
      // Use intrinsic video dimensions
      const videoWidth = video.videoWidth;
      const videoHeight = video.videoHeight;

      // Update minimap canvas size to match video aspect ratio
      const aspectRatio = videoWidth / videoHeight;
      const minimapWidth = 120;
      const minimapHeight = minimapWidth / aspectRatio;

      minimapCanvas.width = minimapWidth;
      minimapCanvas.height = minimapHeight;
      minimapCanvas.style.height = minimapHeight + 'px';

      // Draw video frame to minimap
      const ctx = minimapCanvas.getContext('2d');
      ctx.drawImage(video, 0, 0, minimapWidth, minimapHeight);

      // Calculate viewport rectangle using intrinsic dimensions
      const scaleX = minimapWidth / videoWidth;
      const scaleY = minimapHeight / videoHeight;

      // Viewport position on video: 0 = top-left, negative pan shows more content
      const viewportX = Math.max(0, -panZoomState.translateX) * scaleX;
      const viewportY = Math.max(0, -panZoomState.translateY) * scaleY;
      const viewportW = containerRect.width * scaleX;
      const viewportH = containerRect.height * scaleY;
      
      minimapViewport.style.left = viewportX + 'px';
      minimapViewport.style.top = viewportY + 'px';
      minimapViewport.style.width = Math.min(viewportW, minimapWidth) + 'px';
      minimapViewport.style.height = Math.min(viewportH, minimapHeight) + 'px';
    }
    
    function startMinimapUpdates() {
      if (minimapUpdateInterval) return;
      minimapUpdateInterval = setInterval(() => {
        if (canPan && minimap.classList.contains('visible')) {
          updateMinimap();
        }
      }, 200);
    }
    
    function stopMinimapUpdates() {
      if (minimapUpdateInterval) {
        clearInterval(minimapUpdateInterval);
        minimapUpdateInterval = null;
      }
    }
    
    // Pan/zoom event handlers
    function handlePanStart(e) {
      if (!canPan) return;

      // Stop auto-follow animation when user manually pans
      stopCursorAnimation();

      panZoomState.isPanning = true;
      panZoomContainer.classList.add('panning');
      
      const point = e.touches ? e.touches[0] : e;
      panZoomState.startX = point.clientX - panZoomState.translateX;
      panZoomState.startY = point.clientY - panZoomState.translateY;
      
      e.preventDefault();
    }
    
    function handlePanMove(e) {
      if (!panZoomState.isPanning) return;
      
      const point = e.touches ? e.touches[0] : e;
      const containerRect = mainVideoContainer.getBoundingClientRect();
      
      const maxX = Math.max(0, mainVideo.videoWidth - containerRect.width);
      const maxY = Math.max(0, mainVideo.videoHeight - containerRect.height);
      
      panZoomState.translateX = Math.max(-maxX, Math.min(0, point.clientX - panZoomState.startX));
      panZoomState.translateY = Math.max(-maxY, Math.min(0, point.clientY - panZoomState.startY));
      
      applyPanZoomTransform();
      updateMinimap();
      
      e.preventDefault();
    }
    
    function handlePanEnd(e) {
      panZoomState.isPanning = false;
      panZoomContainer.classList.remove('panning');
    }
    
    // Set up pan/zoom listeners
    panZoomContainer.addEventListener('mousedown', handlePanStart);
    document.addEventListener('mousemove', handlePanMove);
    document.addEventListener('mouseup', handlePanEnd);
    
    panZoomContainer.addEventListener('touchstart', handlePanStart, { passive: false });
    document.addEventListener('touchmove', handlePanMove, { passive: false });
    document.addEventListener('touchend', handlePanEnd);
    
    // Update pan state when scale changes or video loads
    mainVideo.addEventListener('loadedmetadata', () => {
      setTimeout(updatePanZoomState, 100);
    });
    
    mainVideo.addEventListener('resize', updatePanZoomState);
    
    // ==========================================
    // Layout Event Listeners
    // ==========================================
    
    // Layout buttons
    document.querySelectorAll('.layout-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        setLayout(btn.dataset.layout);
      });
    });
    
    // Proportional toggle
    proportionalSwitch.addEventListener('click', toggleProportionalSizing);
    
    // Follow mode toggle
    followSwitch.addEventListener('click', toggleFollowMode);
    
    // ==========================================
    // Keyboard Shortcuts (updated)
    // ==========================================
    
    document.addEventListener('keydown', (e) => {
      // Ignore if typing in an input
      if (e.target.tagName === 'INPUT') return;
      
      switch (e.key.toLowerCase()) {
        case 'f':
          toggleFullscreen();
          break;
        case 'p':
          togglePiP();
          break;
        case 'g':
          if (streamOrder.length > 1) {
            toggleLayout();
          }
          break;
        case 'e':
          if (currentLayout === 'grid') {
            toggleProportionalSizing();
          }
          break;
        case 'i':
          showStats = !showStats;
          document.getElementById('btn-stats').classList.toggle('active', showStats);
          statsPanel.classList.toggle('visible', showStats);
          break;
        case '1':
          setScaleMode('fit');
          break;
        case '2':
          setScaleMode('fill');
          break;
        case '3':
          setScaleMode('native');
          break;
        case '?':
          shortcutsHelp.classList.toggle('visible');
          break;
        case 'escape':
          if (document.fullscreenElement) {
            document.exitFullscreen();
          } else if (document.pictureInPictureElement) {
            document.exitPictureInPicture();
          }
          break;
        case 'arrowleft':
        case 'arrowup':
          if (currentLayout === 'grid' && streamOrder.length > 0) {
            const currentIdx = streamOrder.indexOf(selectedGridIndex);
            const newIdx = currentIdx <= 0 ? streamOrder.length - 1 : currentIdx - 1;
            selectGridCell(streamOrder[newIdx]);
          }
          break;
        case 'arrowright':
        case 'arrowdown':
          if (currentLayout === 'grid' && streamOrder.length > 0) {
            const currentIdx = streamOrder.indexOf(selectedGridIndex);
            const newIdx = currentIdx >= streamOrder.length - 1 ? 0 : currentIdx + 1;
            selectGridCell(streamOrder[newIdx]);
          }
          break;
        case 'enter':
          if (currentLayout === 'grid' && selectedGridIndex !== null) {
            viewerFocusedIndex = selectedGridIndex;
            setLayout('focus');
          }
          break;
      }
    });
    
    function setScaleMode(mode) {
      currentScale = mode;
      mainVideo.className = `main-video scale-${mode}`;

      // Toggle native-mode class for absolute positioning
      panZoomContent.classList.toggle('native-mode', mode === 'native');

      // Update scale buttons
      document.querySelectorAll('.scale-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.scale === mode);
      });

      // Update grid cell videos too
      for (const idx in gridCells) {
        gridCells[idx].video.style.objectFit = mode === 'fill' ? 'cover' : 'contain';
      }

      // Update pan/zoom state
      setTimeout(updatePanZoomState, 50);
    }
    
    // Scale button event listeners
    document.querySelectorAll('.scale-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        setScaleMode(btn.dataset.scale);
      });
    });
    
    // Control button event listeners
    document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
    document.getElementById('btn-pip').addEventListener('click', togglePiP);
    document.getElementById('btn-stats').addEventListener('click', () => {
      showStats = !showStats;
      document.getElementById('btn-stats').classList.toggle('active', showStats);
      statsPanel.classList.toggle('visible', showStats);
    });
    document.getElementById('btn-help').addEventListener('click', () => {
      shortcutsHelp.classList.toggle('visible');
    });
    
    // Double-click to fullscreen
    mainVideoContainer.addEventListener('dblclick', toggleFullscreen);

    // Start minimap updates
    startMinimapUpdates();
    
    // Start
    connect();
  </script>
</body>
</html>
